#warning __TIMESTAMP__
#warning __COUNTER__
#define _WE_USE_ONEWIRE
//#define RTC_NOT_READY
#define _WE_HAVE_OLED_128_64

#include <SPI.h>
#include <SD.h>
#include <avr/pgmspace.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ST7735.h>
#ifdef _WE_HAVE_OLED_128_64
#include <Adafruit_SSD1306.h>
#endif
#include <TimeLib.h>
#include <DS1302RTC.h>
#ifdef _WE_USE_ONEWIRE
#include <OneWire.h>
#endif
#include <Wire.h>

#define RGB(r, g, b) (((r>>3)<<11) | ((g>>2)<<5) | (b>>3)) //RGB888 to RGB565
#define BL			13			//names onboard LED
#define SENSOR_LIGHT	analogRead(A0)	//photoresistor
#define SENSOR_TEMP		analogRead(A1)	//thermistor
#define KEYS_BASE		22			//start pin of keypad
#define KEYS_PINS		8			//how many I/O pins on keypad
#define SIZEOF_CM_ARCH	60//30			//cpu and ram archive size
#define GCX0D			5//13			//cpu graph dot 0,0 X
#define GMX0D			5//93, obsolete, used for separate graphs			//mem graph dot 0,0 X
#define GYHD			15			//top Y of graphs plot region
#define GYLD			65			//bottom Y of graphs plot region
//key-naming {
#define KA1		0x1
#define KB1		0x2
#define KC1		0x4
#define KD1		0x8
#define KA2		0x10
#define KB2		0x20
#define KC2		0x40
#define KD2		0x80
#define KA3		0x100
#define KB3		0x200
#define KC3		0x400
#define KD3		0x800
#define KA4		0x1000
#define KB4		0x2000
#define KC4		0x4000
#define KD4		0x8000
//}
/* распиновка экрана
8пиновая:
1	RST	= TFT reset
2	CS	= TFT CS
3	D/C	= Data/command selector
4	DIN	= MOSI
5	CLK	= SPI SCK, SPI clock
6	VCC
7	BL	= backlight (PWM+)
8	GND

16пиновая:
1	GND
2	VCC
3	*
4	BL	\
5	*	|
6	RST	|
7	RS	|TFT
8	SDA	|
9	SCK	|
10	CS	/
11	CLK	\
12	MISO	|SD
13	MOSI	|Card
14	CS	/
15	*
16	*

D/C = RS = A0
SDA = DIN = MOSI
CS = SS

    Lite - this is the PWM input for the backlight control. Connect to 3-5VDC to turn on the backlight. Connect to ground to turn it off. Or, you can PWM at any frequency.
    MISO - this is the SPI Master In Slave Out pin, its used for the SD card. It isn't used for the TFT display which is write-only
    SCLK - this is the SPI clock input pin
    MOSI - this is the SPI Master Out Slave In pin, it is used to send data from the microcontroller to the SD card and/or TFT
    TFT_CS - this is the TFT SPI chip select pin
    Card CS - this is the SD card chip select, used if you want to read from the SD card.
    D/C - this is the TFT SPI data or command selector pin
    RST - this is the TFT reset pin. Connect to ground to reset the TFT! Its best to have this pin controlled by the library so the display is reset cleanly, but you can also connect it to the Arduino Reset pin, which works for most cases.
    Vcc - this is the power pin, connect to 3-5VDC - it has reverse polarity protection but try to wire it right!
    GND - this is the power and signal ground pin

*/
#define TFT_BL		8	// подсветка
#define TFT_RST	47	// RST = 0 т.к. прицеплено на сброс Ардуины // а походу нихуя так низя :(
#define TFT_CS		48	// CS (was 9 in cpumemmon)
#define TFT_DC		49	// D/C (was 10 in cpumemmon)

#define SD_CS	46	// SDCard channel selector

//fixed	#define notfixed1	//двумерный массив не хочет залазить в функцию аргументом
#define notfixed2	//некоррекно выполняются бинарные операции над несколькими объектами типа color

char* getstr(int id);

int freeRam () {
	extern int __heap_start, *__brkval; int v; 
	return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval); 
}

/// конвертеры
// радианы в градусы
int rad2deg(float rad) { return rad*180/PI; }
// градусы в радианы
float deg2rad(float deg) { return deg*PI/180.0; }
// АЦП в напряжение
float ADC2U(int ADCV) { return ADCV / 1023.0 * 5.0; }
/* калькулятор плеча делителя,
 * Uin	входное напряжение	V
 * Uout	выходное напряжение	V
 * kR	известное плечо	Ω
*/
float RD2R(float Uin, float Uout, uint32_t kR) { return kR / (Uin / Uout - 1); }
/* β-уравнение Стейнхарта-Харта (сопротивление термистора в температуру)
 *  sense	значение АЦП
 *  termR	сопротивление термистора при 25°C	Ω
 *  B	β-коэффициент термистора
*/
float TR2T(int sense, uint32_t termR, float B) { return 1.0/(1.0/298.15 + 1.0/B*log(RD2R(5,ADC2U(sense),termR)/termR))-273.15; }


struct coords {	// структура координат
	byte x; byte y;
	byte w; byte h;
};

class color {		// класс цвета
	public:
		byte red; byte green; byte blue;
		color() { red=0; green=0; blue=0; }
		color(word col16) { red=(col16>>8)&0b11111000; green=(col16>>3)&0b11111100; blue=(col16<<3)&0b11111000; }
		color(byte r, byte g, byte b) { red=r; green=g; blue=b; }
		color &operator+= (const color &x) {
			if ((red+x.red)>255) red=255; else red+=x.red;
			if ((green+x.green)>255) green=255; else green+=x.green;
			if ((blue+x.blue)>255) blue=255; else blue+=x.blue;
			return *this;
		}
		color &operator+ (const color &x) {
			color r(this->red, this->green, this->blue);
			if ((r.red+x.red)>255) r.red=255; else r.red+=x.red;
			if ((r.green+x.green)>255) r.green=255; else r.green+=x.green;
			if ((r.blue+x.blue)>255) r.blue=255; else r.blue+=x.blue;
			return r;			
		}
		color &operator+ (const int col16) {
			color c(this->red, this->green, this->blue);
			color r=(color)col16+c;
			return r;
		}
		color &operator-= (const color &x) {
			if (red<x.red) red=0; else red-=x.red;
			if (green<x.green) green=0; else green-=x.green;
			if (blue<x.blue) blue=0; else blue-=x.blue;
			return *this;
		}
		color &operator- (const color &x) {
			color r(this->red, this->green, this->blue);
			if (r.red<x.red) r.red=0; else r.red-=x.red;
			if (r.green<x.green) r.green=0; else r.green-=x.green;
			if (r.blue<x.blue) r.blue=0; else r.blue-=x.blue;
			return r;			
		}
		color &operator- (const int col16) {
			color c(this->red, this->green, this->blue);
			color r=(color)col16-c;
			return r;
		}
		word get16() {return RGB(red,green,blue);}
};

#ifndef _Time_h // avoid conflict with newlib or other posix libc
typedef long time_t;
#else
#undef dayOfWeek
#endif
#define CLKU_SEC	1
#define CLKU_MIN	2
#define CLKU_HOUR	4
#define CLKU_DAY	8
#define CLKU_MON	16
#define CLKU_YEAR	32
#define SECS_PER_DAY	86400UL
#define LEAP_YEAR(Y)	( ((1970+Y)>0) && !((1970+Y)%4) && ( ((1970+Y)%100) || !((1970+Y)%400) ) )
class clocks {		// класс даты/времени
	public:
		byte dd, dm;	int dy;
		byte th, tm, ts;
		byte upd; // обновление
		/*clocks() {
			dd = 1;	dm = 1;	dy = 0;
			th = 0;	tm = 0;	ts = 0;
			upd = 0b111111;	//full update
		}*/
		clocks(byte ndd, byte ndm, int ndy, byte nth, byte ntm, byte nts) {
			dd = ndd;	dm = ndm;	dy = ndy;
			th = nth;	tm = ntm;	ts = nts;
			upd = 0b111111;	//full update
		}
		clocks() { clocks(1,1,0,0,0,0); }
		void tick() {
			/*byte maxd;
			switch (dm) {
				case 1:
				case 3:
				case 5:
				case 7:
				case 8:
				case 10:
				case 12:
					maxd = 31; break;
				case 4:
				case 6:
				case 9:
				case 11:
					maxd = 30; break;
				case 2: if ((dy % 4)==0) maxd = 29; else maxd = 28; break;
			}*/
			ts++; upd=CLKU_SEC;
			if (ts > 59) { ts=0; tm++; upd=upd|CLKU_MIN; }
			if (tm > 59) { tm=0; th++; upd=upd|CLKU_HOUR; }
			if (th > 23) { th=0; dd++; upd=upd|CLKU_DAY; }
			if (dd > daysOfMonth()) { dd=1; dm++; upd=upd|CLKU_MON; }
			if (dm > 12) { dm=1; dy++; upd=upd|CLKU_YEAR; }
		}
		void set(byte ndd, byte ndm, int ndy, byte nth, byte ntm, byte nts) {
			if (ndd<32) { dd=ndd; upd=upd|CLKU_DAY; }
			if (ndm<13) { dm=ndm; upd=upd|CLKU_MON; }
			if (ndy!=dy) { dy=ndy; upd=upd|CLKU_YEAR; }
			if (nth<25) { th=nth; upd=upd|CLKU_HOUR; }
			if (ntm<60) { tm=ntm; upd=upd|CLKU_MIN; }
			if (nts<60) { ts=nts; upd=upd|CLKU_SEC; }
		}
		void set(time_t ut) {
			ts=ut%60;
			ut/=60; tm=ut%60;
			ut/=60; th=ut%24;
			ut/=24;
			
			int ndy=0; int days=0;
			while((unsigned)(days += (LEAP_YEAR(ndy) ? 366 : 365)) <= ut) { ndy++; }
			dy=ndy+1970;

			days-=LEAP_YEAR(ndy)?366:365;	ut-=days;

			byte mon=0; byte monlen=0;
			for (;mon<12;mon++) {
				monlen=daysOfMonth(mon+1,dy);
				if (ut>=monlen) ut-=monlen; else break;
			}
			/*days=0;
  int month=0;
  int monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(ndy)) {
        monthLength=29;
      } else {
        monthLength=28;
      }
    } else {
    	 byte monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31}; // API starts months from 1, this array starts from 0
      monthLength = monthDays[month];
    }
    
    if (ut >= monthLength) {
      ut -= monthLength;
    } else {
        break;
    }
  }*/
			dm=mon+1; dd=ut+1;
			upd = 0b111111;	//full update
		}
		/*void set2(time_t ut){
			int ndy=1970+ut/(SECS_PER_DAY*365);
			Serial.print("\nstep 1: ndy="); Serial.print(ndy);
			int leapds=0;//(ndy-1969)/4;
			for (int cy=1970;cy<ndy;cy++) if (LEAP_YEAR(cy-1970)) leapds++;
			Serial.print("\nstep 2: leapds="); Serial.print(leapds);
			int days=ut/SECS_PER_DAY;
			Serial.print("\nstep 3: days="); Serial.print(days);
			int ndd=days-leapds;
			Serial.print("\nstep 4: days-leapds="); Serial.print(ndd);			
			ndd%=365;
			Serial.print("\nstep 5: ndd%="); Serial.print(ndd);
			int ndm=1; for (;ndd>daysOfMonth(ndm,ndy);ndm++) ndd-=daysOfMonth(ndm,ndy);
			Serial.print("\nstep 6: ndm="); Serial.print(ndm); Serial.print(", ndd="); Serial.print(ndd);
			long nts=ut-days*SECS_PER_DAY;
			Serial.print("\nstep 7: ut-days*86400="); Serial.print(nts);
			byte nth=nts/3600;
			Serial.print("\nstep 8: nth=nts/3600 =="); Serial.print(nth);
			nts-=nth*3600L;
			Serial.print("\nstep 9: nts-=nth*3600 =="); Serial.print(nts);
			byte ntm=nts/60;
			Serial.print("\nstep 10: ntm="); Serial.print(ntm);
			nts-=ntm*60;
			Serial.print("\nstep 11: nts="); Serial.print(nts);

			set(ndd,ndm,ndy,nth,ntm,nts);
		}*/
		int dayOfWeek(int d, int m, int y) { return (d+=m<3?y--:y-2,23*m/9+d+4+y/4-y/100+y/400)%7; }
		int dayOfWeek() { return dayOfWeek(dd, dm, dy); }
		char* dayOfWeekP(int d, int m, int y) { return getstr(dayOfWeek(d,m,y)+1); } //1 = ID 0-дня недели
		char* dayOfWeekP() { return dayOfWeekP(dd, dm, dy); }
		int daysOfMonth(int m, int y) {
			switch (m) {
				case 4:
				case 6:
				case 9:
				case 11:
					return 30;
				case 2: if ((y % 4)==0) return 29; else return 28;
				default: return 31;
			}
		}
		int daysOfMonth() { return daysOfMonth(dm, dy); }
		time_t UNIX() {
			long secs;
			int uy=dy-1970;	// unixtime is offset
			//count years
			secs=uy*SECS_PER_DAY*365;
			for (int i=0; i<uy; i++) { if (LEAP_YEAR(i)) { secs+= SECS_PER_DAY; } }	// add extra days for leap years
			//count months and all other
			for (int i=1; i<dm; i++) secs+=SECS_PER_DAY*daysOfMonth(i,dy);
			secs+=(dd-1)*SECS_PER_DAY; secs+=th*3600L;
			secs+=tm*60+ts;
			return (time_t)secs;
		}
};

/*struct clocks {	// структура даты/времени
	byte dd = 1;	byte dm = 1;	int dy = 0;
	byte th = 0;	byte tm = 0;	byte ts = 0;
	byte upd = 0; // обновление
};
*/

Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS, TFT_DC, TFT_RST);	// экземпляр класса для моего экрана
#ifndef RTC_NOT_READY
	DS1302RTC RTC(14,15,16);
#endif
#ifdef _WE_HAVE_OLED_128_64
	//Adafruit_SSD1306 oled = Adafruit_SSD1306();
	Adafruit_SSD1306 oled(4);
#endif
byte cpu = 0, mem = 0;				// значения цыпы и памяти
coords scr; float cpubb, membb;		// ширина и высота экрана, а также размеры полосок индикаторов ципы и памяти
unsigned long looptime, lasttime = 0;	// время начала итереции для минимизации вызовов millis() и время последнего получения данных из Serial
unsigned int fps = 0, pulser = 0;		// количество итераций в секунду и время окончания последней итерации в долях/сек
String toparse = "", ret="";			// буферы получения и отправки Serial
char geter; bool istrok = 0;			// последний символ из Serial и флаг готовности к парсингу
unsigned long plen, pnum;			// длина и номер входящего пакета по Serial
char pmode, ptype;					// режим и тип операции из входящего пакета
byte BLs = 0; bool synced = 0;	// состояние инфолампочки и флаг сброса индикаторов цыпы и памяти по таймауту
word nowkey, keystore=0, keysval=0;	// скан-коды клавиатуры текущей итерации, возврата из функции и операционный
byte amode=1; byte pamode=0;			// текущий и предыдущий режимы работы
byte curmenupos=0; byte nowscrstrs=0;	// текущая позиция в меню и количество строк в текущем меню
byte cpuv[SIZEOF_CM_ARCH];			// `|
byte memv[SIZEOF_CM_ARCH];			// значения графиков цыпы и памяти и их последние точки
byte cpul=0, meml=0;				// ,|
float outtemp = 0; int weather = 0;	// температура на улице
bool sdmount=0;
#ifdef _WE_USE_ONEWIRE
OneWire ow(12);
byte ow_addr_out_temp[8] = {0x28,0xff,0x72,0x50,0x71,0x17,0x4,0xd9};
#endif
char strbuf[256]=""; int dbuf=0; bool bbuf=0; color colbuf=0;	// buffers

clocks watches(1,1,1970,0,0,0);	// текущее время
//coords test1;	//for pixmovin test

//incoming modes
#define IM_EMULATE	'E'
#define IM_HELLO	'H'
#define IM_GET		'G'
#define IM_SET		'S'
//incoming packet types
#define IP_EMU_KEY		'K'
#define IP_GET_FREERAM	'F'
#define IP_GET_RUNTIME	'R'
#define IP_GET_WEATHER	'W'
#define IP_SET_CLOCK	'T'
#define IP_SET_CPUMEM	'S'
#define IP_SET_MODE		'M'
#define IP_SET_WEATHER	'W'

// working modes (means current screen content)
#define AMODE_MAINMENU	0
#define AMODE_SUMMARY	1
#define AMODE_CLOCK		2
#define AMODE_SETTINGS		100
#define AMODE_SETTINGS_SCREEN	101
#define AMODE_SETTINGS_SCREEN_BACKLIGHT	102
#define AMODE_SETTINGS_SCREEN_TCOLOR	103
#define AMODE_SETTINGS_SCREEN_BGCOLOR	104
#define AMODE_TEST	255	//sizeof(amode) = 1

const PROGMEM int16_t Alex_B[50][50] = {	//50*50 color
{RGB(0x21, 0x29, 0x15), RGB(0x0d, 0x11, 0x09), RGB(0x11, 0x1c, 0x15), RGB(0x1a, 0x2b, 0x20), RGB(0x18, 0x29, 0x1c), RGB(0x0d, 0x0e, 0x0a), RGB(0x0b, 0x09, 0x07), RGB(0x0b, 0x0b, 0x09), RGB(0x0f, 0x0f, 0x0b), RGB(0x10, 0x13, 0x08), RGB(0x0f, 0x11, 0x09), RGB(0x18, 0x18, 0x0e), RGB(0x1e, 0x1d, 0x0c), RGB(0x21, 0x1a, 0x0f), RGB(0x2d, 0x26, 0x15), RGB(0x30, 0x2a, 0x12), RGB(0x30, 0x27, 0x12), RGB(0x31, 0x26, 0x0f), RGB(0x30, 0x24, 0x10), RGB(0x36, 0x27, 0x12), RGB(0x43, 0x34, 0x15), RGB(0x4b, 0x3b, 0x1f), RGB(0x4b, 0x3b, 0x20), RGB(0x48, 0x38, 0x20), RGB(0x50, 0x3f, 0x25), RGB(0x60, 0x4e, 0x31), RGB(0x78, 0x65, 0x46), RGB(0x84, 0x72, 0x50), RGB(0x82, 0x73, 0x53), RGB(0x82, 0x70, 0x51), RGB(0x92, 0x79, 0x57), RGB(0xa4, 0x8b, 0x66), RGB(0x7b, 0x6c, 0x47), RGB(0x42, 0x32, 0x26), RGB(0x21, 0x1b, 0x22), RGB(0x2a, 0x2d, 0x30), RGB(0x2e, 0x32, 0x36), RGB(0x2b, 0x31, 0x32), RGB(0x26, 0x2a, 0x2f), RGB(0x4e, 0x5a, 0x67), RGB(0x6d, 0x7c, 0x8c), RGB(0x2e, 0x3b, 0x3e), RGB(0x32, 0x39, 0x40), RGB(0x41, 0x51, 0x58), RGB(0x75, 0x8a, 0x8d), RGB(0xa8, 0xbc, 0xc2), RGB(0xb3, 0xc4, 0xc9), RGB(0xab, 0xbd, 0xc1), RGB(0x8f, 0xa3, 0xa8), RGB(0x8d, 0xa1, 0xac)},
{RGB(0x17, 0x1f, 0x15), RGB(0x0c, 0x0d, 0x0a), RGB(0x0c, 0x0f, 0x0a), RGB(0x0c, 0x13, 0x0c), RGB(0x09, 0x0a, 0x05), RGB(0x0a, 0x0b, 0x05), RGB(0x0c, 0x0c, 0x0a), RGB(0x0d, 0x0c, 0x0a), RGB(0x11, 0x11, 0x0c), RGB(0x11, 0x12, 0x09), RGB(0x03, 0x05, 0x20), RGB(0x16, 0x19, 0x0d), RGB(0x30, 0x2a, 0x17), RGB(0x33, 0x29, 0x12), RGB(0x34, 0x28, 0x0f), RGB(0x36, 0x28, 0x11), RGB(0x37, 0x29, 0x16), RGB(0x38, 0x2d, 0x1c), RGB(0x3c, 0x2b, 0x14), RGB(0x3a, 0x28, 0x16), RGB(0x2f, 0x24, 0x0d), RGB(0x39, 0x2f, 0x10), RGB(0x51, 0x3a, 0x20), RGB(0x56, 0x3d, 0x24), RGB(0x53, 0x3d, 0x26), RGB(0x59, 0x45, 0x29), RGB(0x73, 0x5d, 0x3d), RGB(0x83, 0x6e, 0x4e), RGB(0x88, 0x71, 0x53), RGB(0x9b, 0x88, 0x61), RGB(0xa5, 0x90, 0x5f), RGB(0xa9, 0x91, 0x66), RGB(0xbf, 0xa5, 0x77), RGB(0xb1, 0xa0, 0x72), RGB(0x64, 0x5c, 0x4e), RGB(0x20, 0x1f, 0x2d), RGB(0x27, 0x2f, 0x36), RGB(0x34, 0x39, 0x3a), RGB(0x32, 0x33, 0x37), RGB(0x34, 0x3b, 0x3c), RGB(0x6e, 0x7f, 0x8f), RGB(0x48, 0x54, 0x61), RGB(0x2c, 0x36, 0x3e), RGB(0x46, 0x53, 0x5c), RGB(0x5f, 0x72, 0x77), RGB(0xa6, 0xba, 0xbb), RGB(0xbe, 0xcb, 0xd2), RGB(0xba, 0xc6, 0xc8), RGB(0xa2, 0xb4, 0xbb), RGB(0x92, 0xa6, 0xb2)},
{RGB(0x0f, 0x17, 0x10), RGB(0x0a, 0x0d, 0x07), RGB(0x0a, 0x0a, 0x07), RGB(0x0a, 0x07, 0x06), RGB(0x0c, 0x0b, 0x08), RGB(0x0d, 0x0d, 0x08), RGB(0x0c, 0x0c, 0x0a), RGB(0x0f, 0x11, 0x08), RGB(0x10, 0x13, 0x09), RGB(0x17, 0x17, 0x17), RGB(0x28, 0x2a, 0x28), RGB(0x2b, 0x2a, 0x1c), RGB(0x1c, 0x19, 0x0a), RGB(0x1e, 0x1e, 0x10), RGB(0x21, 0x23, 0x11), RGB(0x2a, 0x21, 0x14), RGB(0x43, 0x34, 0x21), RGB(0x41, 0x35, 0x1c), RGB(0x37, 0x23, 0x10), RGB(0x45, 0x33, 0x1d), RGB(0x43, 0x35, 0x18), RGB(0x31, 0x27, 0x11), RGB(0x40, 0x2e, 0x17), RGB(0x53, 0x3c, 0x1f), RGB(0x5b, 0x43, 0x28), RGB(0x5f, 0x45, 0x2a), RGB(0x6d, 0x54, 0x36), RGB(0x79, 0x5f, 0x41), RGB(0x80, 0x67, 0x45), RGB(0x90, 0x7b, 0x57), RGB(0xac, 0x95, 0x68), RGB(0xc0, 0xab, 0x7d), RGB(0xb7, 0xaa, 0x88), RGB(0xc5, 0xb7, 0x95), RGB(0xda, 0xc9, 0xa0), RGB(0x95, 0x8a, 0x72), RGB(0x33, 0x33, 0x38), RGB(0x2d, 0x2e, 0x36), RGB(0x40, 0x3d, 0x42), RGB(0x2a, 0x2c, 0x30), RGB(0x6b, 0x7d, 0x88), RGB(0x68, 0x79, 0x84), RGB(0x23, 0x2f, 0x3c), RGB(0x46, 0x51, 0x5c), RGB(0x56, 0x67, 0x6f), RGB(0xa2, 0xb1, 0xb3), RGB(0xc4, 0xd5, 0xd9), RGB(0xc0, 0xc9, 0xcb), RGB(0xbd, 0xcb, 0xca), RGB(0xa0, 0xb4, 0xbb)},
{RGB(0x12, 0x16, 0x11), RGB(0x0a, 0x0b, 0x07), RGB(0x0c, 0x0c, 0x08), RGB(0x0b, 0x0b, 0x0a), RGB(0x0c, 0x0d, 0x09), RGB(0x0b, 0x0c, 0x08), RGB(0x0c, 0x0c, 0x09), RGB(0x0c, 0x0f, 0x06), RGB(0x13, 0x16, 0x0d), RGB(0x30, 0x2f, 0x2b), RGB(0x5b, 0x53, 0x44), RGB(0x51, 0x45, 0x2c), RGB(0x21, 0x1e, 0x0f), RGB(0x16, 0x18, 0x0a), RGB(0x1d, 0x1c, 0x0c), RGB(0x24, 0x1f, 0x0f), RGB(0x32, 0x25, 0x14), RGB(0x4a, 0x34, 0x1b), RGB(0x43, 0x30, 0x15), RGB(0x35, 0x27, 0x13), RGB(0x49, 0x37, 0x1a), RGB(0x54, 0x3e, 0x20), RGB(0x46, 0x30, 0x19), RGB(0x48, 0x36, 0x17), RGB(0x5f, 0x4a, 0x25), RGB(0x71, 0x50, 0x31), RGB(0x70, 0x52, 0x36), RGB(0x7b, 0x5a, 0x3e), RGB(0x82, 0x63, 0x3f), RGB(0x8c, 0x6f, 0x4d), RGB(0x92, 0x76, 0x59), RGB(0xa1, 0x85, 0x61), RGB(0xca, 0xbb, 0x96), RGB(0xcc, 0xc5, 0xa9), RGB(0xca, 0xb9, 0x9e), RGB(0xe7, 0xd8, 0xae), RGB(0xb6, 0xae, 0x94), RGB(0x40, 0x41, 0x41), RGB(0x29, 0x27, 0x30), RGB(0x31, 0x36, 0x3c), RGB(0x58, 0x65, 0x73), RGB(0x7b, 0x89, 0x9f), RGB(0x2a, 0x3b, 0x47), RGB(0x43, 0x53, 0x58), RGB(0x59, 0x61, 0x71), RGB(0x97, 0x9e, 0xaa), RGB(0xcc, 0xd9, 0xdc), RGB(0xba, 0xc9, 0xcd), RGB(0xce, 0xd4, 0xcf), RGB(0xc0, 0xcb, 0xcd)},
{RGB(0x0e, 0x0d, 0x0a), RGB(0x0e, 0x0d, 0x0a), RGB(0x0d, 0x0d, 0x09), RGB(0x0c, 0x0c, 0x0c), RGB(0x0c, 0x0d, 0x09), RGB(0x0a, 0x0b, 0x04), RGB(0x13, 0x13, 0x0b), RGB(0x22, 0x21, 0x12), RGB(0x2f, 0x2b, 0x19), RGB(0x2d, 0x27, 0x11), RGB(0x23, 0x20, 0x0b), RGB(0x40, 0x36, 0x19), RGB(0x5f, 0x49, 0x27), RGB(0x55, 0x46, 0x27), RGB(0x41, 0x32, 0x19), RGB(0x39, 0x29, 0x0e), RGB(0x32, 0x24, 0x0b), RGB(0x42, 0x2f, 0x1a), RGB(0x63, 0x4b, 0x28), RGB(0x4e, 0x3b, 0x1d), RGB(0x3b, 0x28, 0x14), RGB(0x5c, 0x42, 0x23), RGB(0x64, 0x49, 0x27), RGB(0x57, 0x3c, 0x24), RGB(0x67, 0x4d, 0x2f), RGB(0x7f, 0x64, 0x44), RGB(0x83, 0x61, 0x3c), RGB(0x84, 0x60, 0x3e), RGB(0x83, 0x61, 0x41), RGB(0x98, 0x75, 0x4e), RGB(0xac, 0x8d, 0x5f), RGB(0x9c, 0x81, 0x5d), RGB(0x99, 0x7d, 0x5b), RGB(0xcb, 0xc5, 0xa1), RGB(0xd0, 0xd0, 0xc0), RGB(0xca, 0xc3, 0xb1), RGB(0xe7, 0xe4, 0xc9), RGB(0xc2, 0xc4, 0xba), RGB(0x4d, 0x4f, 0x52), RGB(0x29, 0x29, 0x2e), RGB(0x42, 0x48, 0x50), RGB(0x7e, 0x89, 0x9c), RGB(0x4a, 0x56, 0x66), RGB(0x38, 0x4a, 0x54), RGB(0x59, 0x64, 0x70), RGB(0x81, 0x8c, 0x97), RGB(0xcd, 0xd3, 0xd6), RGB(0xbe, 0xcd, 0xd0), RGB(0xc9, 0xcd, 0xd0), RGB(0xcf, 0xd0, 0xd2)},
{RGB(0x0a, 0x0a, 0x07), RGB(0x0d, 0x0d, 0x0a), RGB(0x0e, 0x0d, 0x0a), RGB(0x0b, 0x0c, 0x0b), RGB(0x0a, 0x0d, 0x0b), RGB(0x1a, 0x19, 0x0e), RGB(0x28, 0x25, 0x17), RGB(0x31, 0x30, 0x1a), RGB(0x32, 0x2e, 0x16), RGB(0x22, 0x1e, 0x0c), RGB(0x07, 0x0a, 0x04), RGB(0x0d, 0x0b, 0x06), RGB(0x3c, 0x2c, 0x14), RGB(0x75, 0x5c, 0x36), RGB(0x78, 0x64, 0x3d), RGB(0x56, 0x3e, 0x1d), RGB(0x4d, 0x36, 0x17), RGB(0x48, 0x34, 0x16), RGB(0x55, 0x3c, 0x1e), RGB(0x71, 0x54, 0x2b), RGB(0x68, 0x4d, 0x2b), RGB(0x55, 0x37, 0x1c), RGB(0x77, 0x56, 0x2e), RGB(0x7e, 0x60, 0x3b), RGB(0x64, 0x42, 0x29), RGB(0x7b, 0x5f, 0x43), RGB(0x9a, 0x7b, 0x50), RGB(0x9d, 0x79, 0x4f), RGB(0x90, 0x69, 0x48), RGB(0x9c, 0x73, 0x4b), RGB(0xb0, 0x8e, 0x5f), RGB(0xce, 0xb9, 0x92), RGB(0xab, 0x91, 0x7a), RGB(0xa5, 0x8c, 0x72), RGB(0xd0, 0xce, 0xb6), RGB(0xcf, 0xd1, 0xcb), RGB(0xc9, 0xcb, 0xc3), RGB(0xe7, 0xe7, 0xe4), RGB(0xca, 0xca, 0xca), RGB(0x46, 0x45, 0x4a), RGB(0x21, 0x24, 0x28), RGB(0x7b, 0x84, 0x92), RGB(0x6c, 0x74, 0x8b), RGB(0x2f, 0x3d, 0x4c), RGB(0x55, 0x65, 0x71), RGB(0x71, 0x80, 0x89), RGB(0xc5, 0xc8, 0xca), RGB(0xc5, 0xd1, 0xd2), RGB(0xba, 0xc6, 0xcd), RGB(0xc2, 0xc6, 0xc7)},
{RGB(0x0b, 0x0b, 0x08), RGB(0x0d, 0x0d, 0x0a), RGB(0x0d, 0x0c, 0x0a), RGB(0x0b, 0x0c, 0x0b), RGB(0x19, 0x1a, 0x0d), RGB(0x2a, 0x25, 0x13), RGB(0x28, 0x21, 0x13), RGB(0x1d, 0x20, 0x0d), RGB(0x1c, 0x1b, 0x0e), RGB(0x21, 0x1d, 0x11), RGB(0x17, 0x14, 0x0a), RGB(0x0f, 0x11, 0x0c), RGB(0x13, 0x15, 0x09), RGB(0x46, 0x32, 0x11), RGB(0x86, 0x69, 0x3e), RGB(0x80, 0x69, 0x46), RGB(0x70, 0x51, 0x33), RGB(0x64, 0x46, 0x28), RGB(0x51, 0x37, 0x1d), RGB(0x69, 0x48, 0x28), RGB(0x94, 0x72, 0x41), RGB(0x7a, 0x5b, 0x36), RGB(0x65, 0x43, 0x22), RGB(0x90, 0x6e, 0x3f), RGB(0x95, 0x74, 0x48), RGB(0x89, 0x67, 0x44), RGB(0x89, 0x66, 0x41), RGB(0xa8, 0x84, 0x51), RGB(0xb6, 0x98, 0x62), RGB(0xad, 0x85, 0x5b), RGB(0xaf, 0x89, 0x63), RGB(0xc4, 0xa9, 0x7e), RGB(0xd5, 0xc2, 0xa8), RGB(0xb6, 0xa3, 0x94), RGB(0xb3, 0x9f, 0x83), RGB(0xd0, 0xcb, 0xb3), RGB(0xcf, 0xd3, 0xce), RGB(0xcb, 0xcc, 0xcd), RGB(0xe6, 0xe4, 0xe3), RGB(0xbe, 0xbe, 0xbf), RGB(0x39, 0x3b, 0x40), RGB(0x51, 0x5d, 0x68), RGB(0x80, 0x8b, 0x9f), RGB(0x3e, 0x48, 0x59), RGB(0x54, 0x62, 0x70), RGB(0x67, 0x74, 0x80), RGB(0xbc, 0xc1, 0xc3), RGB(0xca, 0xd1, 0xd5), RGB(0xba, 0xc5, 0xc8), RGB(0xa6, 0xb3, 0xba)},
{RGB(0x0c, 0x0c, 0x08), RGB(0x0f, 0x0e, 0x0b), RGB(0x0d, 0x0d, 0x0a), RGB(0x14, 0x13, 0x0c), RGB(0x24, 0x20, 0x0a), RGB(0x24, 0x1f, 0x08), RGB(0x1f, 0x19, 0x0c), RGB(0x17, 0x18, 0x0c), RGB(0x10, 0x12, 0x0a), RGB(0x1a, 0x1a, 0x0a), RGB(0x21, 0x1f, 0x0e), RGB(0x1f, 0x1d, 0x13), RGB(0x1f, 0x1f, 0x14), RGB(0x26, 0x1a, 0x08), RGB(0x5b, 0x3c, 0x1e), RGB(0x8e, 0x76, 0x4c), RGB(0x88, 0x6b, 0x42), RGB(0x82, 0x5d, 0x39), RGB(0x79, 0x5c, 0x35), RGB(0x69, 0x4a, 0x2c), RGB(0x7e, 0x59, 0x39), RGB(0x9b, 0x78, 0x49), RGB(0x83, 0x61, 0x3c), RGB(0x78, 0x51, 0x30), RGB(0x9d, 0x78, 0x46), RGB(0xa9, 0x89, 0x55), RGB(0xa1, 0x7e, 0x53), RGB(0x9c, 0x7d, 0x55), RGB(0xc7, 0xb5, 0x87), RGB(0xc4, 0xad, 0x86), RGB(0xb8, 0x98, 0x78), RGB(0xb8, 0x99, 0x79), RGB(0xd1, 0xbc, 0x9c), RGB(0xd5, 0xc9, 0xb7), RGB(0xb4, 0xa8, 0xa3), RGB(0xbc, 0xb2, 0xa0), RGB(0xd3, 0xd0, 0xb8), RGB(0xcb, 0xcf, 0xcb), RGB(0xcd, 0xcc, 0xd0), RGB(0xee, 0xec, 0xea), RGB(0xa0, 0xa2, 0xa2), RGB(0x33, 0x3d, 0x46), RGB(0x85, 0x8d, 0x9f), RGB(0x52, 0x5d, 0x6f), RGB(0x47, 0x59, 0x63), RGB(0x61, 0x73, 0x80), RGB(0xb4, 0xb9, 0xbf), RGB(0xcc, 0xd0, 0xd6), RGB(0xbe, 0xc8, 0xca), RGB(0xab, 0xb6, 0xbe)},
{RGB(0x0d, 0x0c, 0x09), RGB(0x0d, 0x0f, 0x0a), RGB(0x13, 0x14, 0x0c), RGB(0x22, 0x1c, 0x0b), RGB(0x25, 0x1f, 0x0c), RGB(0x1a, 0x1a, 0x0b), RGB(0x0f, 0x12, 0x08), RGB(0x0c, 0x0d, 0x07), RGB(0x09, 0x0b, 0x08), RGB(0x0d, 0x12, 0x08), RGB(0x24, 0x20, 0x12), RGB(0x32, 0x29, 0x1a), RGB(0x39, 0x2f, 0x21), RGB(0x3a, 0x2c, 0x1f), RGB(0x3b, 0x27, 0x14), RGB(0x77, 0x5a, 0x2e), RGB(0x9e, 0x80, 0x54), RGB(0x88, 0x65, 0x38), RGB(0x89, 0x68, 0x35), RGB(0x92, 0x74, 0x45), RGB(0x83, 0x5f, 0x41), RGB(0x86, 0x5f, 0x3b), RGB(0xac, 0x88, 0x57), RGB(0x91, 0x6d, 0x51), RGB(0x80, 0x55, 0x37), RGB(0xaa, 0x85, 0x51), RGB(0xcb, 0xb2, 0x79), RGB(0xb1, 0x98, 0x79), RGB(0xb0, 0x9b, 0x80), RGB(0xd4, 0xca, 0xa9), RGB(0xc7, 0xb5, 0x9a), RGB(0xbf, 0xa5, 0x90), RGB(0xc6, 0xb8, 0x9f), RGB(0xd7, 0xd8, 0xc9), RGB(0xcd, 0xca, 0xc5), RGB(0xb5, 0xab, 0xaa), RGB(0xc2, 0xbc, 0xad), RGB(0xd2, 0xd1, 0xba), RGB(0xcb, 0xcd, 0xcd), RGB(0xd0, 0xd1, 0xd1), RGB(0xe6, 0xe5, 0xe5), RGB(0x6d, 0x71, 0x76), RGB(0x69, 0x75, 0x84), RGB(0x70, 0x7b, 0x8d), RGB(0x43, 0x4c, 0x59), RGB(0x60, 0x6d, 0x7f), RGB(0xaa, 0xaf, 0xb9), RGB(0xd4, 0xd6, 0xd5), RGB(0xbb, 0xc5, 0xcd), RGB(0xb6, 0xc1, 0xc8)},
{RGB(0x0c, 0x0c, 0x0a), RGB(0x0e, 0x12, 0x09), RGB(0x1d, 0x1d, 0x0e), RGB(0x29, 0x23, 0x0f), RGB(0x20, 0x1c, 0x0b), RGB(0x0f, 0x10, 0x07), RGB(0x08, 0x0b, 0x05), RGB(0x08, 0x08, 0x05), RGB(0x08, 0x09, 0x08), RGB(0x0e, 0x12, 0x09), RGB(0x2b, 0x28, 0x16), RGB(0x3d, 0x31, 0x1e), RGB(0x40, 0x34, 0x22), RGB(0x44, 0x35, 0x29), RGB(0x3f, 0x31, 0x23), RGB(0x47, 0x2e, 0x13), RGB(0x86, 0x63, 0x39), RGB(0xb1, 0x9e, 0x6d), RGB(0x9f, 0x82, 0x50), RGB(0xa3, 0x7d, 0x49), RGB(0xb0, 0x93, 0x64), RGB(0x99, 0x75, 0x51), RGB(0xa7, 0x7f, 0x50), RGB(0xb2, 0x94, 0x6a), RGB(0x9b, 0x78, 0x57), RGB(0x9d, 0x6e, 0x49), RGB(0xb9, 0x9a, 0x6d), RGB(0xd6, 0xc5, 0x9d), RGB(0xae, 0x98, 0x82), RGB(0xc2, 0xb7, 0xa2), RGB(0xd2, 0xcd, 0xba), RGB(0xc7, 0xba, 0xac), RGB(0xc3, 0xb5, 0xaa), RGB(0xca, 0xc7, 0xbc), RGB(0xd4, 0xd4, 0xce), RGB(0xc7, 0xc5, 0xc5), RGB(0xb1, 0xab, 0xb0), RGB(0xca, 0xc6, 0xb4), RGB(0xd1, 0xcd, 0xc1), RGB(0xcb, 0xcb, 0xce), RGB(0xde, 0xdd, 0xdc), RGB(0xbe, 0xbd, 0xbe), RGB(0x6d, 0x7a, 0x81), RGB(0x77, 0x87, 0x95), RGB(0x44, 0x4f, 0x61), RGB(0x58, 0x63, 0x75), RGB(0x9c, 0xa4, 0xaf), RGB(0xd8, 0xd8, 0xd6), RGB(0xb9, 0xc6, 0xcd), RGB(0xc6, 0xcd, 0xd3)},
{RGB(0x0e, 0x0f, 0x09), RGB(0x11, 0x13, 0x07), RGB(0x25, 0x26, 0x11), RGB(0x2d, 0x2a, 0x1a), RGB(0x16, 0x15, 0x0a), RGB(0x09, 0x0a, 0x09), RGB(0x09, 0x08, 0x06), RGB(0x06, 0x06, 0x02), RGB(0x0b, 0x0b, 0x07), RGB(0x24, 0x1d, 0x12), RGB(0x38, 0x2f, 0x1d), RGB(0x3c, 0x32, 0x21), RGB(0x3f, 0x31, 0x22), RGB(0x43, 0x33, 0x24), RGB(0x47, 0x34, 0x25), RGB(0x44, 0x31, 0x20), RGB(0x57, 0x3b, 0x19), RGB(0x91, 0x76, 0x45), RGB(0xc4, 0xac, 0x7d), RGB(0xb4, 0x93, 0x5f), RGB(0xbd, 0xa3, 0x6b), RGB(0xc1, 0xad, 0x86), RGB(0xb1, 0x96, 0x74), RGB(0xc8, 0xb1, 0x80), RGB(0xb9, 0x9f, 0x79), RGB(0xa8, 0x89, 0x73), RGB(0xaa, 0x85, 0x67), RGB(0xcb, 0xb7, 0x95), RGB(0xc4, 0xbd, 0xac), RGB(0xb0, 0xa4, 0x9a), RGB(0xd1, 0xd2, 0xc4), RGB(0xcb, 0xca, 0xc2), RGB(0xc4, 0xb8, 0xb3), RGB(0xc0, 0xb5, 0xad), RGB(0xd0, 0xd0, 0xcb), RGB(0xd3, 0xd1, 0xd0), RGB(0xbf, 0xb8, 0xba), RGB(0xb4, 0xac, 0xa9), RGB(0xd2, 0xcf, 0xc0), RGB(0xce, 0xce, 0xc9), RGB(0xcc, 0xcd, 0xc9), RGB(0xe2, 0xdf, 0xdb), RGB(0xa8, 0xac, 0xab), RGB(0x84, 0x91, 0x9c), RGB(0x52, 0x5b, 0x71), RGB(0x4f, 0x5b, 0x6c), RGB(0x88, 0x93, 0xa2), RGB(0xce, 0xd1, 0xcf), RGB(0xba, 0xc7, 0xcc), RGB(0xcb, 0xcc, 0xcf)},
{RGB(0x0d, 0x10, 0x06), RGB(0x17, 0x18, 0x0c), RGB(0x29, 0x27, 0x11), RGB(0x23, 0x1e, 0x0c), RGB(0x14, 0x12, 0x08), RGB(0x0b, 0x0d, 0x09), RGB(0x08, 0x08, 0x05), RGB(0x04, 0x04, 0x01), RGB(0x14, 0x13, 0x0c), RGB(0x36, 0x2b, 0x1b), RGB(0x3e, 0x34, 0x21), RGB(0x3b, 0x31, 0x21), RGB(0x42, 0x2f, 0x22), RGB(0x46, 0x35, 0x23), RGB(0x47, 0x35, 0x22), RGB(0x46, 0x32, 0x24), RGB(0x4e, 0x3b, 0x26), RGB(0x67, 0x47, 0x1e), RGB(0x8f, 0x72, 0x44), RGB(0xc4, 0xae, 0x81), RGB(0xc0, 0xa4, 0x69), RGB(0xca, 0xbf, 0x93), RGB(0xc9, 0xbc, 0x9c), RGB(0xd3, 0xca, 0xa3), RGB(0xcb, 0xbd, 0x9c), RGB(0xb7, 0xa1, 0x88), RGB(0xb3, 0x9d, 0x8c), RGB(0xb2, 0x97, 0x83), RGB(0xcd, 0xc6, 0xb1), RGB(0xbc, 0xb4, 0xae), RGB(0xc4, 0xbd, 0xb5), RGB(0xd2, 0xd4, 0xc9), RGB(0xc9, 0xc4, 0xc2), RGB(0xbd, 0xae, 0xaa), RGB(0xc5, 0xbe, 0xba), RGB(0xd2, 0xd3, 0xd2), RGB(0xd0, 0xcd, 0xcd), RGB(0xab, 0xa4, 0xa4), RGB(0xb9, 0xb7, 0xae), RGB(0xd6, 0xda, 0xd0), RGB(0xcb, 0xcc, 0xcb), RGB(0xd2, 0xd1, 0xcf), RGB(0xd7, 0xd5, 0xd1), RGB(0xb5, 0xb9, 0xc2), RGB(0x5d, 0x69, 0x7f), RGB(0x43, 0x52, 0x64), RGB(0x76, 0x85, 0x96), RGB(0xc2, 0xca, 0xcb), RGB(0xc4, 0xcc, 0xd3), RGB(0xc6, 0xc8, 0xca)},
{RGB(0x0d, 0x0f, 0x07), RGB(0x1e, 0x1e, 0x11), RGB(0x27, 0x24, 0x10), RGB(0x20, 0x19, 0x06), RGB(0x13, 0x11, 0x08), RGB(0x0c, 0x0e, 0x08), RGB(0x08, 0x08, 0x06), RGB(0x06, 0x06, 0x04), RGB(0x1d, 0x1b, 0x11), RGB(0x3a, 0x30, 0x1d), RGB(0x3e, 0x34, 0x22), RGB(0x3f, 0x32, 0x24), RGB(0x42, 0x33, 0x24), RGB(0x45, 0x33, 0x24), RGB(0x46, 0x33, 0x23), RGB(0x47, 0x33, 0x27), RGB(0x48, 0x35, 0x26), RGB(0x59, 0x43, 0x2f), RGB(0x66, 0x49, 0x29), RGB(0x8c, 0x6d, 0x40), RGB(0xc7, 0xb0, 0x84), RGB(0xce, 0xba, 0x89), RGB(0xca, 0xbf, 0x9a), RGB(0xc9, 0xb8, 0x99), RGB(0xd2, 0xcd, 0xb2), RGB(0xc4, 0xb9, 0x9c), RGB(0xbd, 0xaa, 0x9b), RGB(0xb5, 0xa4, 0x98), RGB(0xbe, 0xac, 0x9d), RGB(0xcb, 0xc5, 0xbb), RGB(0xc0, 0xb3, 0xae), RGB(0xce, 0xc7, 0xbc), RGB(0xcc, 0xcb, 0xca), RGB(0xc3, 0xb9, 0xbb), RGB(0xbb, 0xac, 0xa8), RGB(0xcb, 0xc9, 0xc7), RGB(0xce, 0xcf, 0xce), RGB(0xbc, 0xbe, 0xbe), RGB(0x9b, 0x90, 0x94), RGB(0xc6, 0xc4, 0xb6), RGB(0xd3, 0xd7, 0xd3), RGB(0xcb, 0xca, 0xcc), RGB(0xd5, 0xd4, 0xcd), RGB(0xdc, 0xd9, 0xdc), RGB(0x81, 0x86, 0x9b), RGB(0x3a, 0x48, 0x5c), RGB(0x65, 0x76, 0x8b), RGB(0xb5, 0xbd, 0xc6), RGB(0xcb, 0xd5, 0xda), RGB(0xc3, 0xc8, 0xce)},
{RGB(0x10, 0x11, 0x0a), RGB(0x23, 0x23, 0x11), RGB(0x26, 0x22, 0x0c), RGB(0x21, 0x18, 0x0a), RGB(0x13, 0x12, 0x09), RGB(0x09, 0x0b, 0x06), RGB(0x07, 0x07, 0x05), RGB(0x0b, 0x0b, 0x09), RGB(0x21, 0x20, 0x14), RGB(0x39, 0x31, 0x1e), RGB(0x40, 0x36, 0x24), RGB(0x42, 0x35, 0x27), RGB(0x44, 0x35, 0x27), RGB(0x45, 0x35, 0x27), RGB(0x46, 0x33, 0x26), RGB(0x46, 0x32, 0x25), RGB(0x48, 0x33, 0x25), RGB(0x48, 0x38, 0x2a), RGB(0x62, 0x4e, 0x3b), RGB(0x6e, 0x49, 0x2b), RGB(0x94, 0x6e, 0x48), RGB(0xd2, 0xbc, 0x8c), RGB(0xcd, 0xbf, 0x9f), RGB(0xcb, 0xbe, 0xa5), RGB(0xce, 0xc5, 0xa8), RGB(0xd0, 0xce, 0xb8), RGB(0xbf, 0xae, 0xa1), RGB(0xb7, 0xa5, 0xa0), RGB(0xb0, 0xa4, 0xa0), RGB(0xc5, 0xbb, 0xb2), RGB(0xc7, 0xc4, 0xbd), RGB(0xc0, 0xb4, 0xac), RGB(0xd0, 0xcb, 0xc3), RGB(0xc9, 0xc6, 0xc6), RGB(0xba, 0xac, 0xa7), RGB(0xc0, 0xb7, 0xae), RGB(0xce, 0xcf, 0xc7), RGB(0xc8, 0xc7, 0xcb), RGB(0x9d, 0x96, 0x99), RGB(0x9c, 0x8d, 0x84), RGB(0xd8, 0xd9, 0xcb), RGB(0xce, 0xd0, 0xcc), RGB(0xcc, 0xcd, 0xc8), RGB(0xdc, 0xdc, 0xd0), RGB(0xc1, 0xc1, 0xc8), RGB(0x4a, 0x53, 0x69), RGB(0x53, 0x60, 0x77), RGB(0xa0, 0xab, 0xb7), RGB(0xcc, 0xd4, 0xd6), RGB(0xbf, 0xc9, 0xd0)},
{RGB(0x15, 0x17, 0x0f), RGB(0x23, 0x23, 0x12), RGB(0x28, 0x1f, 0x09), RGB(0x22, 0x19, 0x09), RGB(0x14, 0x12, 0x0b), RGB(0x0b, 0x0d, 0x09), RGB(0x07, 0x07, 0x06), RGB(0x0c, 0x0f, 0x08), RGB(0x2b, 0x27, 0x19), RGB(0x3d, 0x34, 0x23), RGB(0x42, 0x37, 0x28), RGB(0x44, 0x37, 0x2a), RGB(0x45, 0x37, 0x29), RGB(0x45, 0x36, 0x27), RGB(0x45, 0x34, 0x26), RGB(0x45, 0x33, 0x24), RGB(0x46, 0x33, 0x24), RGB(0x48, 0x34, 0x24), RGB(0x4d, 0x35, 0x2c), RGB(0x6a, 0x52, 0x46), RGB(0x73, 0x51, 0x33), RGB(0xa0, 0x7f, 0x54), RGB(0xd2, 0xbf, 0x92), RGB(0xd2, 0xcf, 0xb8), RGB(0xcf, 0xc9, 0xb8), RGB(0xd1, 0xc8, 0xb3), RGB(0xcb, 0xc9, 0xbd), RGB(0xb7, 0xa7, 0xa4), RGB(0xb4, 0xa6, 0xa3), RGB(0xb6, 0xa6, 0x9f), RGB(0xc8, 0xc1, 0xb8), RGB(0xc6, 0xc4, 0xc2), RGB(0xc7, 0xbd, 0xb3), RGB(0xcc, 0xc9, 0xc3), RGB(0xc6, 0xbc, 0xb7), RGB(0xb8, 0xaa, 0xa3), RGB(0xc7, 0xbe, 0xb4), RGB(0xcf, 0xca, 0xc9), RGB(0xb9, 0xb6, 0xb6), RGB(0x80, 0x72, 0x72), RGB(0xb0, 0xa3, 0x95), RGB(0xda, 0xda, 0xca), RGB(0xcd, 0xce, 0xcc), RGB(0xce, 0xcf, 0xc4), RGB(0xe4, 0xe4, 0xda), RGB(0x8d, 0x91, 0x99), RGB(0x48, 0x53, 0x67), RGB(0x82, 0x94, 0xa6), RGB(0xc7, 0xcd, 0xcf), RGB(0xbc, 0xcb, 0xd2)},
{RGB(0x16, 0x17, 0x10), RGB(0x20, 0x20, 0x0e), RGB(0x2a, 0x22, 0x0d), RGB(0x24, 0x1c, 0x08), RGB(0x17, 0x16, 0x08), RGB(0x0e, 0x10, 0x0a), RGB(0x08, 0x08, 0x08), RGB(0x0e, 0x10, 0x0b), RGB(0x33, 0x2d, 0x1b), RGB(0x3f, 0x37, 0x27), RGB(0x43, 0x39, 0x2b), RGB(0x44, 0x37, 0x29), RGB(0x45, 0x36, 0x28), RGB(0x45, 0x35, 0x28), RGB(0x45, 0x34, 0x27), RGB(0x45, 0x33, 0x25), RGB(0x47, 0x32, 0x24), RGB(0x4a, 0x30, 0x24), RGB(0x4c, 0x2d, 0x24), RGB(0x50, 0x35, 0x28), RGB(0x75, 0x5e, 0x4d), RGB(0x7c, 0x61, 0x4b), RGB(0x9d, 0x7d, 0x53), RGB(0xcc, 0xb1, 0x8e), RGB(0xd2, 0xca, 0xb6), RGB(0xce, 0xcb, 0xb8), RGB(0xd2, 0xd5, 0xc3), RGB(0xc7, 0xc5, 0xbc), RGB(0xb4, 0xa1, 0x9d), RGB(0xad, 0x9d, 0x97), RGB(0xb1, 0xa2, 0x9c), RGB(0xce, 0xcb, 0xc1), RGB(0xca, 0xc2, 0xb8), RGB(0xcb, 0xc3, 0xba), RGB(0xcc, 0xcb, 0xc7), RGB(0xbc, 0xae, 0xa8), RGB(0xb6, 0xa4, 0x9a), RGB(0xcd, 0xc5, 0xbc), RGB(0xcc, 0xc7, 0xc6), RGB(0x8f, 0x87, 0x8b), RGB(0x76, 0x63, 0x61), RGB(0xcd, 0xc4, 0xaf), RGB(0xd4, 0xd5, 0xc9), RGB(0xcb, 0xcd, 0xca), RGB(0xd8, 0xd9, 0xd2), RGB(0xca, 0xc9, 0xc4), RGB(0x5d, 0x67, 0x73), RGB(0x61, 0x78, 0x8b), RGB(0xbf, 0xc7, 0xc8), RGB(0xc4, 0xce, 0xd6)},
{RGB(0x16, 0x13, 0x0d), RGB(0x1e, 0x1c, 0x0b), RGB(0x2d, 0x26, 0x0d), RGB(0x26, 0x1d, 0x0b), RGB(0x18, 0x17, 0x08), RGB(0x0c, 0x0f, 0x09), RGB(0x08, 0x08, 0x07), RGB(0x14, 0x15, 0x10), RGB(0x37, 0x34, 0x21), RGB(0x41, 0x3b, 0x28), RGB(0x43, 0x38, 0x28), RGB(0x45, 0x34, 0x29), RGB(0x46, 0x36, 0x29), RGB(0x45, 0x35, 0x29), RGB(0x45, 0x34, 0x28), RGB(0x46, 0x32, 0x27), RGB(0x48, 0x31, 0x26), RGB(0x4a, 0x30, 0x25), RGB(0x4c, 0x2f, 0x24), RGB(0x4f, 0x2f, 0x22), RGB(0x55, 0x3d, 0x2b), RGB(0x7c, 0x62, 0x55), RGB(0x86, 0x60, 0x4e), RGB(0xa2, 0x82, 0x5d), RGB(0xc4, 0xaf, 0x89), RGB(0xd0, 0xc5, 0xac), RGB(0xd2, 0xcd, 0xc1), RGB(0xd3, 0xd3, 0xc4), RGB(0xc6, 0xbe, 0xb0), RGB(0xb0, 0x9f, 0x9b), RGB(0xa1, 0x90, 0x8f), RGB(0xaf, 0x9f, 0x93), RGB(0xce, 0xc8, 0xbd), RGB(0xcc, 0xc9, 0xc0), RGB(0xcc, 0xcb, 0xc4), RGB(0xc9, 0xc0, 0xb9), RGB(0xb5, 0xa1, 0x9b), RGB(0xbe, 0xae, 0xa2), RGB(0xc9, 0xc6, 0xbf), RGB(0xbb, 0xb6, 0xb9), RGB(0x6d, 0x5e, 0x64), RGB(0x8b, 0x7a, 0x6b), RGB(0xd9, 0xd1, 0xbb), RGB(0xcf, 0xd0, 0xc9), RGB(0xcb, 0xcf, 0xc7), RGB(0xda, 0xd8, 0xcb), RGB(0xa2, 0xa7, 0xa8), RGB(0x59, 0x6d, 0x7f), RGB(0xa8, 0xb3, 0xbb), RGB(0xce, 0xd3, 0xd7)},
{RGB(0x14, 0x14, 0x0b), RGB(0x1a, 0x19, 0x09), RGB(0x2a, 0x24, 0x0d), RGB(0x23, 0x1d, 0x0f), RGB(0x18, 0x17, 0x0b), RGB(0x0c, 0x0d, 0x07), RGB(0x08, 0x08, 0x06), RGB(0x1b, 0x1d, 0x12), RGB(0x40, 0x38, 0x2c), RGB(0x44, 0x3b, 0x2c), RGB(0x45, 0x39, 0x2b), RGB(0x46, 0x37, 0x2c), RGB(0x47, 0x37, 0x2c), RGB(0x47, 0x36, 0x2b), RGB(0x47, 0x34, 0x2a), RGB(0x47, 0x32, 0x29), RGB(0x48, 0x31, 0x27), RGB(0x4a, 0x31, 0x26), RGB(0x4c, 0x31, 0x26), RGB(0x4e, 0x32, 0x25), RGB(0x4e, 0x31, 0x23), RGB(0x5b, 0x38, 0x2b), RGB(0x84, 0x66, 0x53), RGB(0x88, 0x6c, 0x5d), RGB(0xa1, 0x89, 0x6e), RGB(0xbf, 0xa4, 0x7e), RGB(0xd1, 0xbc, 0xa1), RGB(0xd3, 0xcb, 0xba), RGB(0xd6, 0xd2, 0xc3), RGB(0xbe, 0xb0, 0xaa), RGB(0xa3, 0x94, 0x92), RGB(0x99, 0x85, 0x7f), RGB(0xb0, 0x9b, 0x91), RGB(0xc7, 0xc2, 0xb7), RGB(0xd1, 0xcf, 0xc2), RGB(0xd2, 0xd8, 0xcc), RGB(0xbd, 0xaf, 0xaa), RGB(0xb0, 0x98, 0x91), RGB(0xc3, 0xb7, 0xa9), RGB(0xc8, 0xc6, 0xbb), RGB(0x96, 0x93, 0x99), RGB(0x61, 0x4e, 0x53), RGB(0xb2, 0xa2, 0x8b), RGB(0xd7, 0xd3, 0xbd), RGB(0xce, 0xd2, 0xc6), RGB(0xd5, 0xd8, 0xc7), RGB(0xb5, 0xb8, 0xb4), RGB(0x67, 0x74, 0x85), RGB(0x93, 0xa2, 0xac), RGB(0xcf, 0xd4, 0xd5)},
{RGB(0x0e, 0x10, 0x08), RGB(0x12, 0x12, 0x0a), RGB(0x23, 0x22, 0x10), RGB(0x1f, 0x1e, 0x10), RGB(0x15, 0x15, 0x0b), RGB(0x0c, 0x0b, 0x07), RGB(0x08, 0x0a, 0x09), RGB(0x1f, 0x22, 0x16), RGB(0x45, 0x38, 0x2a), RGB(0x46, 0x3c, 0x2c), RGB(0x47, 0x3c, 0x2f), RGB(0x48, 0x3c, 0x30), RGB(0x48, 0x3a, 0x2f), RGB(0x48, 0x37, 0x2e), RGB(0x48, 0x33, 0x2c), RGB(0x48, 0x32, 0x2a), RGB(0x49, 0x31, 0x29), RGB(0x4a, 0x31, 0x28), RGB(0x4c, 0x32, 0x28), RGB(0x4e, 0x33, 0x28), RGB(0x52, 0x34, 0x2a), RGB(0x55, 0x32, 0x29), RGB(0x5c, 0x3c, 0x2b), RGB(0x7a, 0x57, 0x48), RGB(0x89, 0x6c, 0x56), RGB(0xa4, 0x8d, 0x71), RGB(0xba, 0x9c, 0x7c), RGB(0xcd, 0xb6, 0x9d), RGB(0xd4, 0xcc, 0xbd), RGB(0xd5, 0xd0, 0xc2), RGB(0xbe, 0xb2, 0xa9), RGB(0xa3, 0x94, 0x8f), RGB(0xa1, 0x89, 0x81), RGB(0xb1, 0x9a, 0x8f), RGB(0xbf, 0xae, 0x9f), RGB(0xd2, 0xd0, 0xc3), RGB(0xce, 0xcf, 0xc8), RGB(0xb0, 0x9b, 0x94), RGB(0xb5, 0x9f, 0x93), RGB(0xc9, 0xbf, 0xb3), RGB(0xc2, 0xc3, 0xc2), RGB(0x79, 0x6d, 0x74), RGB(0x79, 0x63, 0x5c), RGB(0xcf, 0xc4, 0xa9), RGB(0xd3, 0xcf, 0xc0), RGB(0xd5, 0xd7, 0xcd), RGB(0xb8, 0xbc, 0xb7), RGB(0x63, 0x6a, 0x7c), RGB(0x80, 0x91, 0x9b), RGB(0xca, 0xd3, 0xd4)},
{RGB(0x10, 0x11, 0x0b), RGB(0x10, 0x11, 0x0b), RGB(0x1f, 0x1f, 0x13), RGB(0x1e, 0x1f, 0x13), RGB(0x15, 0x17, 0x0b), RGB(0x0d, 0x0c, 0x07), RGB(0x06, 0x06, 0x05), RGB(0x1e, 0x1f, 0x17), RGB(0x42, 0x3a, 0x2e), RGB(0x46, 0x3a, 0x2e), RGB(0x47, 0x3f, 0x35), RGB(0x48, 0x3f, 0x37), RGB(0x47, 0x3c, 0x31), RGB(0x47, 0x36, 0x2f), RGB(0x47, 0x33, 0x2c), RGB(0x48, 0x30, 0x2a), RGB(0x49, 0x31, 0x29), RGB(0x4a, 0x32, 0x29), RGB(0x4c, 0x32, 0x2a), RGB(0x4e, 0x33, 0x2b), RGB(0x50, 0x34, 0x2a), RGB(0x52, 0x34, 0x29), RGB(0x51, 0x31, 0x27), RGB(0x56, 0x32, 0x24), RGB(0x6d, 0x4a, 0x37), RGB(0x81, 0x5d, 0x4f), RGB(0x9b, 0x79, 0x5f), RGB(0xb9, 0x9b, 0x77), RGB(0xcc, 0xb6, 0x9c), RGB(0xcd, 0xbc, 0xae), RGB(0xd3, 0xcc, 0xbb), RGB(0xc5, 0xbc, 0xb4), RGB(0xab, 0x97, 0x93), RGB(0xae, 0x96, 0x8e), RGB(0xb0, 0x99, 0x88), RGB(0xba, 0xa4, 0x8d), RGB(0xd4, 0xd1, 0xc1), RGB(0xce, 0xcc, 0xc9), RGB(0xac, 0x94, 0x8d), RGB(0xb4, 0x9b, 0x90), RGB(0xcf, 0xc9, 0xbb), RGB(0xae, 0xae, 0xad), RGB(0x64, 0x51, 0x58), RGB(0xa2, 0x91, 0x7e), RGB(0xd6, 0xce, 0xb6), RGB(0xd2, 0xce, 0xbf), RGB(0xcf, 0xce, 0xc8), RGB(0x7b, 0x7e, 0x89), RGB(0x6d, 0x7c, 0x8d), RGB(0xc5, 0xd1, 0xd3)},
{RGB(0x0e, 0x0f, 0x0d), RGB(0x09, 0x09, 0x07), RGB(0x15, 0x11, 0x0b), RGB(0x1a, 0x19, 0x13), RGB(0x15, 0x17, 0x11), RGB(0x0e, 0x0e, 0x0a), RGB(0x03, 0x03, 0x01), RGB(0x18, 0x18, 0x14), RGB(0x44, 0x3e, 0x33), RGB(0x42, 0x36, 0x2c), RGB(0x3f, 0x36, 0x2f), RGB(0x3f, 0x3b, 0x32), RGB(0x43, 0x39, 0x30), RGB(0x44, 0x32, 0x2d), RGB(0x42, 0x2f, 0x29), RGB(0x45, 0x30, 0x28), RGB(0x48, 0x32, 0x2a), RGB(0x4b, 0x33, 0x2b), RGB(0x4d, 0x33, 0x2b), RGB(0x4d, 0x33, 0x2b), RGB(0x4e, 0x33, 0x2a), RGB(0x4e, 0x32, 0x29), RGB(0x46, 0x2e, 0x26), RGB(0x3b, 0x22, 0x16), RGB(0x3c, 0x27, 0x1d), RGB(0x5b, 0x3b, 0x2e), RGB(0x77, 0x4d, 0x37), RGB(0x8c, 0x64, 0x48), RGB(0xae, 0x8b, 0x6c), RGB(0xc7, 0xa8, 0x92), RGB(0xc6, 0xae, 0x9a), RGB(0xce, 0xc0, 0xaf), RGB(0xcd, 0xc8, 0xbc), RGB(0xb1, 0x9f, 0x9d), RGB(0xab, 0x96, 0x8a), RGB(0xb3, 0x9f, 0x8f), RGB(0xbd, 0xa4, 0x8f), RGB(0xd3, 0xcd, 0xbe), RGB(0xcb, 0xca, 0xc7), RGB(0xaf, 0x98, 0x94), RGB(0xb3, 0x95, 0x89), RGB(0xd1, 0xc7, 0xbb), RGB(0x92, 0x8c, 0x8b), RGB(0x71, 0x5b, 0x56), RGB(0xc0, 0xad, 0x91), RGB(0xcf, 0xc7, 0xb3), RGB(0xd0, 0xcc, 0xbf), RGB(0x9f, 0xa4, 0xae), RGB(0x5e, 0x72, 0x8d), RGB(0xb6, 0xc2, 0xc9)},
{RGB(0x06, 0x06, 0x04), RGB(0x05, 0x05, 0x03), RGB(0x0c, 0x0c, 0x06), RGB(0x14, 0x15, 0x0e), RGB(0x13, 0x13, 0x12), RGB(0x14, 0x16, 0x0e), RGB(0x06, 0x06, 0x03), RGB(0x14, 0x14, 0x12), RGB(0x39, 0x36, 0x27), RGB(0x32, 0x2e, 0x21), RGB(0x31, 0x2e, 0x26), RGB(0x30, 0x2e, 0x2c), RGB(0x34, 0x2f, 0x2a), RGB(0x31, 0x29, 0x24), RGB(0x30, 0x27, 0x20), RGB(0x3d, 0x2d, 0x23), RGB(0x48, 0x34, 0x2c), RGB(0x4e, 0x35, 0x2d), RGB(0x4d, 0x35, 0x2d), RGB(0x4c, 0x33, 0x2c), RGB(0x4d, 0x31, 0x2a), RGB(0x4b, 0x30, 0x29), RGB(0x45, 0x2f, 0x24), RGB(0x42, 0x2c, 0x22), RGB(0x3c, 0x2b, 0x20), RGB(0x3b, 0x28, 0x20), RGB(0x4a, 0x2b, 0x21), RGB(0x61, 0x35, 0x23), RGB(0x7a, 0x4e, 0x33), RGB(0x9f, 0x76, 0x63), RGB(0xbb, 0x97, 0x82), RGB(0xc1, 0xa1, 0x86), RGB(0xca, 0xbb, 0xa6), RGB(0xcc, 0xc4, 0xb9), RGB(0xb3, 0xa2, 0x9e), RGB(0xaf, 0x99, 0x8f), RGB(0xb7, 0x9a, 0x88), RGB(0xbb, 0xa2, 0x89), RGB(0xd0, 0xcd, 0xb9), RGB(0xcf, 0xd1, 0xca), RGB(0xb9, 0xa9, 0x9f), RGB(0xbb, 0xa7, 0x9a), RGB(0xcc, 0xc6, 0xbb), RGB(0x88, 0x79, 0x79), RGB(0x8b, 0x73, 0x63), RGB(0xcb, 0xc3, 0xaa), RGB(0xd0, 0xcc, 0xb9), RGB(0xba, 0xb9, 0xbf), RGB(0x72, 0x89, 0xa8), RGB(0x75, 0x85, 0x98)},
{RGB(0x09, 0x08, 0x03), RGB(0x08, 0x07, 0x04), RGB(0x0b, 0x0d, 0x07), RGB(0x13, 0x15, 0x0b), RGB(0x14, 0x14, 0x0d), RGB(0x18, 0x19, 0x0e), RGB(0x0a, 0x0a, 0x05), RGB(0x0d, 0x12, 0x0e), RGB(0x36, 0x39, 0x2e), RGB(0x47, 0x46, 0x3f), RGB(0x45, 0x40, 0x3e), RGB(0x45, 0x37, 0x3c), RGB(0x3c, 0x36, 0x36), RGB(0x3f, 0x33, 0x31), RGB(0x3a, 0x2f, 0x2a), RGB(0x3e, 0x31, 0x26), RGB(0x4b, 0x37, 0x31), RGB(0x4e, 0x3c, 0x35), RGB(0x4d, 0x37, 0x30), RGB(0x4c, 0x34, 0x2c), RGB(0x4e, 0x2e, 0x28), RGB(0x50, 0x2d, 0x26), RGB(0x49, 0x2d, 0x26), RGB(0x38, 0x23, 0x1c), RGB(0x32, 0x1f, 0x19), RGB(0x2d, 0x1d, 0x17), RGB(0x22, 0x1f, 0x1b), RGB(0x25, 0x1a, 0x17), RGB(0x42, 0x26, 0x12), RGB(0x67, 0x40, 0x2a), RGB(0x85, 0x62, 0x48), RGB(0xa7, 0x85, 0x6c), RGB(0xb7, 0x93, 0x78), RGB(0xc3, 0xac, 0x9a), RGB(0xc9, 0xbd, 0xb5), RGB(0xb4, 0xa3, 0x99), RGB(0xb1, 0x9f, 0x92), RGB(0xb4, 0x9b, 0x8b), RGB(0xbc, 0xa1, 0x88), RGB(0xd0, 0xc7, 0xb5), RGB(0xd1, 0xd6, 0xcc), RGB(0xc4, 0xc1, 0xb8), RGB(0xc5, 0xb7, 0xaf), RGB(0xc0, 0xb8, 0xaf), RGB(0x92, 0x83, 0x7f), RGB(0xa9, 0x92, 0x7f), RGB(0xd2, 0xcb, 0xb0), RGB(0xa3, 0xa2, 0x9d), RGB(0x5d, 0x68, 0x7d), RGB(0x39, 0x44, 0x62)},
{RGB(0x17, 0x23, 0x1b), RGB(0x0c, 0x09, 0x06), RGB(0x0c, 0x0b, 0x08), RGB(0x11, 0x11, 0x0a), RGB(0x19, 0x19, 0x0f), RGB(0x1a, 0x18, 0x0f), RGB(0x0f, 0x0d, 0x04), RGB(0x16, 0x15, 0x0f), RGB(0x48, 0x48, 0x43), RGB(0x50, 0x4c, 0x4a), RGB(0x49, 0x3b, 0x37), RGB(0x3b, 0x2e, 0x26), RGB(0x2a, 0x23, 0x18), RGB(0x28, 0x21, 0x1c), RGB(0x2c, 0x24, 0x1d), RGB(0x37, 0x29, 0x22), RGB(0x47, 0x36, 0x2a), RGB(0x53, 0x42, 0x3b), RGB(0x51, 0x3e, 0x39), RGB(0x4f, 0x34, 0x2b), RGB(0x4e, 0x2c, 0x21), RGB(0x52, 0x2b, 0x1e), RGB(0x41, 0x21, 0x19), RGB(0x2a, 0x17, 0x11), RGB(0x1f, 0x14, 0x10), RGB(0x1a, 0x14, 0x0e), RGB(0x22, 0x1f, 0x1a), RGB(0x14, 0x19, 0x19), RGB(0x1b, 0x13, 0x0f), RGB(0x43, 0x22, 0x14), RGB(0x5e, 0x36, 0x24), RGB(0x76, 0x49, 0x34), RGB(0x9c, 0x73, 0x55), RGB(0xb0, 0x8e, 0x75), RGB(0xc2, 0xad, 0x9c), RGB(0xcd, 0xc4, 0xb8), RGB(0xb5, 0xa5, 0xa0), RGB(0xb9, 0xa4, 0x98), RGB(0xba, 0x9f, 0x88), RGB(0xba, 0xa0, 0x8b), RGB(0xc7, 0xb9, 0xab), RGB(0xd2, 0xcd, 0xbf), RGB(0xc9, 0xc6, 0xbd), RGB(0xc2, 0xb6, 0xaf), RGB(0xbe, 0xb3, 0xa7), RGB(0x9c, 0x86, 0x73), RGB(0xbe, 0xb1, 0x95), RGB(0xab, 0xa8, 0xa0), RGB(0x52, 0x55, 0x60), RGB(0x34, 0x42, 0x4d)},
{RGB(0x1d, 0x33, 0x26), RGB(0x0d, 0x10, 0x0c), RGB(0x0c, 0x0a, 0x0a), RGB(0x0c, 0x0e, 0x0b), RGB(0x16, 0x1a, 0x0d), RGB(0x1e, 0x1e, 0x12), RGB(0x16, 0x12, 0x0a), RGB(0x13, 0x10, 0x09), RGB(0x42, 0x40, 0x3e), RGB(0x4a, 0x44, 0x3f), RGB(0x2a, 0x21, 0x1b), RGB(0x1a, 0x19, 0x15), RGB(0x18, 0x1e, 0x1f), RGB(0x05, 0x08, 0x07), RGB(0x07, 0x09, 0x05), RGB(0x11, 0x12, 0x10), RGB(0x1c, 0x17, 0x0e), RGB(0x41, 0x31, 0x2b), RGB(0x58, 0x46, 0x3d), RGB(0x52, 0x32, 0x29), RGB(0x53, 0x2d, 0x22), RGB(0x55, 0x2e, 0x22), RGB(0x3e, 0x20, 0x13), RGB(0x2c, 0x1a, 0x10), RGB(0x21, 0x15, 0x0f), RGB(0x22, 0x18, 0x11), RGB(0x2b, 0x1a, 0x17), RGB(0x30, 0x1d, 0x1b), RGB(0x33, 0x20, 0x1f), RGB(0x3f, 0x26, 0x21), RGB(0x4e, 0x2b, 0x20), RGB(0x5f, 0x33, 0x24), RGB(0x6f, 0x47, 0x2f), RGB(0x92, 0x6e, 0x52), RGB(0xaf, 0x8d, 0x73), RGB(0xc5, 0xaf, 0x9a), RGB(0xcb, 0xbd, 0xb1), RGB(0xb9, 0xaa, 0xa1), RGB(0xb9, 0xa9, 0x99), RGB(0xb6, 0xa4, 0x91), RGB(0xbc, 0xa5, 0x90), RGB(0xc7, 0xb4, 0xa4), RGB(0xcd, 0xc1, 0xb4), RGB(0xc4, 0xbb, 0xae), RGB(0xbc, 0xb2, 0xa5), RGB(0xaa, 0x94, 0x7f), RGB(0xa8, 0x92, 0x71), RGB(0xae, 0xa8, 0x9f), RGB(0x5a, 0x5c, 0x66), RGB(0x2e, 0x39, 0x42)},
{RGB(0x24, 0x38, 0x2c), RGB(0x14, 0x1c, 0x16), RGB(0x0b, 0x0b, 0x08), RGB(0x0d, 0x0e, 0x0c), RGB(0x13, 0x14, 0x0e), RGB(0x21, 0x22, 0x12), RGB(0x1f, 0x1d, 0x11), RGB(0x0d, 0x0b, 0x04), RGB(0x3f, 0x3d, 0x36), RGB(0x3f, 0x3a, 0x31), RGB(0x09, 0x07, 0x20), RGB(0x15, 0x1b, 0x1a), RGB(0x21, 0x2b, 0x31), RGB(0x0d, 0x11, 0x12), RGB(0x10, 0x0f, 0x0a), RGB(0x13, 0x11, 0x0e), RGB(0x17, 0x14, 0x11), RGB(0x35, 0x2c, 0x22), RGB(0x52, 0x3a, 0x2e), RGB(0x53, 0x2f, 0x24), RGB(0x55, 0x33, 0x26), RGB(0x5a, 0x35, 0x2a), RGB(0x51, 0x2a, 0x1b), RGB(0x3e, 0x1e, 0x11), RGB(0x2b, 0x17, 0x13), RGB(0x2c, 0x1a, 0x14), RGB(0x31, 0x1c, 0x18), RGB(0x34, 0x1f, 0x1e), RGB(0x39, 0x23, 0x1f), RGB(0x40, 0x28, 0x19), RGB(0x48, 0x29, 0x1a), RGB(0x56, 0x32, 0x24), RGB(0x61, 0x39, 0x29), RGB(0x6b, 0x40, 0x29), RGB(0x7e, 0x51, 0x3a), RGB(0x9c, 0x77, 0x5c), RGB(0xc6, 0xad, 0x96), RGB(0xc8, 0xba, 0xac), RGB(0xb8, 0xa6, 0x9f), RGB(0xbb, 0xa9, 0x9a), RGB(0xb9, 0xa7, 0x93), RGB(0xbb, 0xa4, 0x96), RGB(0xc5, 0xb1, 0xa4), RGB(0xcc, 0xc2, 0xb2), RGB(0xc2, 0xbe, 0xb4), RGB(0xad, 0x9f, 0x94), RGB(0x9f, 0x82, 0x66), RGB(0xa7, 0x9a, 0x8a), RGB(0x4d, 0x51, 0x5d), RGB(0x26, 0x2c, 0x39)},
{RGB(0x28, 0x39, 0x32), RGB(0x1f, 0x26, 0x1e), RGB(0x0f, 0x0e, 0x07), RGB(0x10, 0x12, 0x0b), RGB(0x11, 0x11, 0x10), RGB(0x1d, 0x1c, 0x12), RGB(0x26, 0x25, 0x14), RGB(0x15, 0x13, 0x0a), RGB(0x33, 0x32, 0x28), RGB(0x47, 0x41, 0x36), RGB(0x3a, 0x34, 0x2c), RGB(0x3f, 0x3b, 0x36), RGB(0x35, 0x2b, 0x24), RGB(0x34, 0x29, 0x24), RGB(0x2f, 0x1f, 0x1d), RGB(0x27, 0x1b, 0x12), RGB(0x30, 0x24, 0x19), RGB(0x42, 0x34, 0x2d), RGB(0x4d, 0x37, 0x28), RGB(0x51, 0x2f, 0x26), RGB(0x57, 0x35, 0x31), RGB(0x57, 0x36, 0x2c), RGB(0x56, 0x30, 0x24), RGB(0x50, 0x29, 0x1c), RGB(0x42, 0x1f, 0x14), RGB(0x3b, 0x1c, 0x13), RGB(0x38, 0x1a, 0x16), RGB(0x38, 0x1c, 0x17), RGB(0x40, 0x20, 0x18), RGB(0x49, 0x26, 0x18), RGB(0x51, 0x2c, 0x1d), RGB(0x59, 0x32, 0x20), RGB(0x61, 0x37, 0x25), RGB(0x61, 0x36, 0x26), RGB(0x61, 0x35, 0x26), RGB(0x73, 0x49, 0x37), RGB(0x93, 0x69, 0x4f), RGB(0xb6, 0x98, 0x7c), RGB(0xcd, 0xbf, 0xb0), RGB(0xc7, 0xba, 0xae), RGB(0xbf, 0xb1, 0xa5), RGB(0xb7, 0xa4, 0x99), RGB(0xbc, 0xa9, 0x9a), RGB(0xc2, 0xb0, 0xa5), RGB(0xc6, 0xba, 0xa7), RGB(0xc1, 0xba, 0xad), RGB(0x9d, 0x89, 0x76), RGB(0xaa, 0x9a, 0x86), RGB(0x4f, 0x55, 0x5e), RGB(0x19, 0x23, 0x30)},
{RGB(0x22, 0x3a, 0x2b), RGB(0x23, 0x30, 0x28), RGB(0x11, 0x13, 0x0d), RGB(0x11, 0x11, 0x0d), RGB(0x12, 0x12, 0x10), RGB(0x17, 0x17, 0x12), RGB(0x20, 0x21, 0x14), RGB(0x1c, 0x1c, 0x12), RGB(0x33, 0x31, 0x26), RGB(0x50, 0x46, 0x39), RGB(0x4a, 0x3c, 0x32), RGB(0x48, 0x3e, 0x38), RGB(0x48, 0x37, 0x32), RGB(0x41, 0x2d, 0x28), RGB(0x36, 0x25, 0x1f), RGB(0x33, 0x23, 0x1d), RGB(0x3b, 0x2a, 0x21), RGB(0x46, 0x31, 0x2c), RGB(0x4c, 0x32, 0x2a), RGB(0x62, 0x45, 0x42), RGB(0x78, 0x61, 0x66), RGB(0x63, 0x41, 0x39), RGB(0x58, 0x32, 0x2b), RGB(0x5c, 0x36, 0x34), RGB(0x57, 0x31, 0x28), RGB(0x4d, 0x26, 0x1e), RGB(0x4c, 0x26, 0x1c), RGB(0x4d, 0x28, 0x1f), RGB(0x50, 0x2a, 0x21), RGB(0x56, 0x30, 0x26), RGB(0x5d, 0x39, 0x2f), RGB(0x65, 0x41, 0x39), RGB(0x6a, 0x42, 0x38), RGB(0x6b, 0x41, 0x38), RGB(0x65, 0x3d, 0x33), RGB(0x69, 0x38, 0x2f), RGB(0x75, 0x43, 0x31), RGB(0x80, 0x51, 0x37), RGB(0x92, 0x6f, 0x52), RGB(0xac, 0x8f, 0x76), RGB(0xc5, 0xb1, 0x9e), RGB(0xd0, 0xbf, 0xaf), RGB(0xc7, 0xb4, 0xa8), RGB(0xbb, 0xa5, 0x9c), RGB(0xaa, 0x8f, 0x80), RGB(0xaf, 0x9b, 0x87), RGB(0x97, 0x87, 0x72), RGB(0xa1, 0x92, 0x81), RGB(0x67, 0x69, 0x70), RGB(0x18, 0x21, 0x2d)},
{RGB(0x21, 0x36, 0x2b), RGB(0x20, 0x37, 0x2c), RGB(0x19, 0x1d, 0x17), RGB(0x13, 0x0e, 0x0b), RGB(0x13, 0x13, 0x0f), RGB(0x15, 0x16, 0x12), RGB(0x18, 0x19, 0x13), RGB(0x15, 0x16, 0x10), RGB(0x32, 0x30, 0x2e), RGB(0x53, 0x4a, 0x40), RGB(0x47, 0x35, 0x2b), RGB(0x3a, 0x23, 0x20), RGB(0x35, 0x22, 0x20), RGB(0x36, 0x25, 0x1d), RGB(0x36, 0x25, 0x1b), RGB(0x3d, 0x28, 0x23), RGB(0x46, 0x30, 0x29), RGB(0x46, 0x33, 0x26), RGB(0x58, 0x36, 0x35), RGB(0x92, 0x74, 0x7f), RGB(0xb2, 0xa4, 0xb9), RGB(0x98, 0x7d, 0x86), RGB(0x72, 0x4c, 0x4e), RGB(0x65, 0x40, 0x43), RGB(0x5c, 0x36, 0x35), RGB(0x53, 0x2c, 0x25), RGB(0x52, 0x2c, 0x26), RGB(0x53, 0x31, 0x29), RGB(0x55, 0x30, 0x2a), RGB(0x59, 0x34, 0x2d), RGB(0x5f, 0x39, 0x36), RGB(0x6a, 0x47, 0x4a), RGB(0x6e, 0x4f, 0x4c), RGB(0x6b, 0x46, 0x3f), RGB(0x6e, 0x42, 0x37), RGB(0x6d, 0x40, 0x36), RGB(0x7b, 0x54, 0x45), RGB(0x8f, 0x6f, 0x61), RGB(0x65, 0x3f, 0x2d), RGB(0x64, 0x3c, 0x26), RGB(0x85, 0x61, 0x4a), RGB(0x9b, 0x79, 0x60), RGB(0xac, 0x8f, 0x79), RGB(0xbc, 0xab, 0x9a), RGB(0xad, 0x97, 0x89), RGB(0x8b, 0x6d, 0x5e), RGB(0x6c, 0x4f, 0x3e), RGB(0x99, 0x85, 0x72), RGB(0x7d, 0x79, 0x79), RGB(0x26, 0x2d, 0x38)},
{RGB(0x22, 0x36, 0x2d), RGB(0x23, 0x3b, 0x30), RGB(0x1d, 0x28, 0x20), RGB(0x12, 0x0f, 0x0c), RGB(0x13, 0x14, 0x10), RGB(0x13, 0x13, 0x0f), RGB(0x17, 0x16, 0x12), RGB(0x10, 0x12, 0x0a), RGB(0x24, 0x25, 0x25), RGB(0x52, 0x4f, 0x49), RGB(0x52, 0x43, 0x3e), RGB(0x47, 0x2f, 0x2c), RGB(0x3c, 0x27, 0x21), RGB(0x3d, 0x25, 0x1b), RGB(0x3e, 0x24, 0x1b), RGB(0x43, 0x2a, 0x23), RGB(0x51, 0x39, 0x34), RGB(0x4a, 0x38, 0x30), RGB(0x6a, 0x47, 0x4b), RGB(0xb6, 0x95, 0xad), RGB(0xcd, 0xbe, 0xd8), RGB(0xcd, 0xbf, 0xd5), RGB(0xa6, 0x88, 0x98), RGB(0x72, 0x48, 0x48), RGB(0x52, 0x2e, 0x29), RGB(0x52, 0x2c, 0x2a), RGB(0x56, 0x2d, 0x2e), RGB(0x57, 0x2e, 0x2f), RGB(0x59, 0x35, 0x35), RGB(0x62, 0x40, 0x3e), RGB(0x6b, 0x48, 0x47), RGB(0x6d, 0x4d, 0x47), RGB(0x6d, 0x50, 0x49), RGB(0x6e, 0x4d, 0x43), RGB(0x6f, 0x4b, 0x3c), RGB(0x6f, 0x46, 0x3a), RGB(0x79, 0x51, 0x41), RGB(0x94, 0x79, 0x71), RGB(0x5a, 0x45, 0x40), RGB(0x45, 0x2b, 0x20), RGB(0x49, 0x2d, 0x23), RGB(0x41, 0x1f, 0x12), RGB(0x4f, 0x2c, 0x1b), RGB(0x76, 0x5c, 0x4c), RGB(0x94, 0x7f, 0x6a), RGB(0x92, 0x7e, 0x6d), RGB(0x6f, 0x56, 0x44), RGB(0x91, 0x7b, 0x68), RGB(0x7b, 0x7a, 0x75), RGB(0x2a, 0x33, 0x38)},
{RGB(0x23, 0x35, 0x31), RGB(0x21, 0x37, 0x32), RGB(0x1e, 0x30, 0x2c), RGB(0x14, 0x13, 0x11), RGB(0x15, 0x13, 0x11), RGB(0x14, 0x13, 0x14), RGB(0x14, 0x14, 0x14), RGB(0x13, 0x13, 0x0f), RGB(0x1b, 0x1d, 0x1c), RGB(0x4b, 0x47, 0x48), RGB(0x54, 0x4a, 0x41), RGB(0x4d, 0x39, 0x32), RGB(0x48, 0x30, 0x2a), RGB(0x43, 0x2b, 0x28), RGB(0x42, 0x26, 0x25), RGB(0x41, 0x27, 0x25), RGB(0x4f, 0x3a, 0x37), RGB(0x4f, 0x3a, 0x35), RGB(0x6d, 0x4b, 0x4d), RGB(0xb9, 0x97, 0xac), RGB(0xcf, 0xc3, 0xd5), RGB(0xd4, 0xd3, 0xdb), RGB(0xcc, 0xbf, 0xcb), RGB(0xae, 0x8b, 0x9b), RGB(0x78, 0x51, 0x59), RGB(0x49, 0x1e, 0x1e), RGB(0x59, 0x2f, 0x2e), RGB(0x5d, 0x34, 0x39), RGB(0x5b, 0x3b, 0x3e), RGB(0x6d, 0x4b, 0x4f), RGB(0x7c, 0x62, 0x68), RGB(0x86, 0x72, 0x78), RGB(0x85, 0x6f, 0x6f), RGB(0x78, 0x5d, 0x56), RGB(0x73, 0x54, 0x44), RGB(0x75, 0x4d, 0x3e), RGB(0x7d, 0x54, 0x41), RGB(0x98, 0x7b, 0x74), RGB(0x52, 0x41, 0x40), RGB(0x37, 0x1e, 0x17), RGB(0x45, 0x25, 0x1d), RGB(0x49, 0x28, 0x1f), RGB(0x4e, 0x30, 0x22), RGB(0x52, 0x33, 0x26), RGB(0x56, 0x35, 0x27), RGB(0x65, 0x4c, 0x3b), RGB(0x7b, 0x64, 0x51), RGB(0xa6, 0x91, 0x84), RGB(0x71, 0x6f, 0x71), RGB(0x1c, 0x21, 0x2a)},
{RGB(0x22, 0x34, 0x34), RGB(0x22, 0x31, 0x34), RGB(0x23, 0x34, 0x32), RGB(0x16, 0x1d, 0x18), RGB(0x12, 0x11, 0x0f), RGB(0x15, 0x16, 0x16), RGB(0x15, 0x15, 0x16), RGB(0x15, 0x14, 0x13), RGB(0x10, 0x13, 0x12), RGB(0x43, 0x43, 0x40), RGB(0x58, 0x51, 0x48), RGB(0x4f, 0x43, 0x41), RGB(0x4d, 0x38, 0x37), RGB(0x44, 0x2c, 0x2a), RGB(0x41, 0x28, 0x26), RGB(0x44, 0x26, 0x25), RGB(0x47, 0x29, 0x28), RGB(0x49, 0x2f, 0x2c), RGB(0x69, 0x47, 0x4b), RGB(0xae, 0x8b, 0x9c), RGB(0xd0, 0xc2, 0xd3), RGB(0xd2, 0xd4, 0xd6), RGB(0xdb, 0xe1, 0xe3), RGB(0xe8, 0xeb, 0xf4), RGB(0xd8, 0xc8, 0xda), RGB(0x66, 0x3f, 0x47), RGB(0x43, 0x1a, 0x18), RGB(0x5d, 0x39, 0x39), RGB(0x61, 0x3c, 0x3b), RGB(0x63, 0x42, 0x42), RGB(0x74, 0x5b, 0x60), RGB(0x88, 0x74, 0x83), RGB(0x96, 0x87, 0x91), RGB(0x8d, 0x7a, 0x79), RGB(0x77, 0x5e, 0x51), RGB(0x76, 0x59, 0x46), RGB(0x84, 0x60, 0x4b), RGB(0xa3, 0x84, 0x7d), RGB(0x4e, 0x3e, 0x3f), RGB(0x2f, 0x19, 0x17), RGB(0x40, 0x26, 0x1d), RGB(0x47, 0x2e, 0x20), RGB(0x52, 0x32, 0x27), RGB(0x52, 0x2c, 0x21), RGB(0x55, 0x33, 0x25), RGB(0x55, 0x3d, 0x2d), RGB(0x8c, 0x79, 0x6b), RGB(0xa5, 0x92, 0x8e), RGB(0x7e, 0x75, 0x70), RGB(0x58, 0x5a, 0x55)},
{RGB(0x22, 0x35, 0x2e), RGB(0x22, 0x33, 0x35), RGB(0x21, 0x38, 0x36), RGB(0x1a, 0x27, 0x25), RGB(0x11, 0x10, 0x0f), RGB(0x13, 0x15, 0x15), RGB(0x16, 0x15, 0x16), RGB(0x15, 0x15, 0x15), RGB(0x0e, 0x0f, 0x11), RGB(0x41, 0x41, 0x40), RGB(0x5f, 0x55, 0x54), RGB(0x54, 0x48, 0x47), RGB(0x4e, 0x40, 0x3e), RGB(0x47, 0x2e, 0x2c), RGB(0x44, 0x29, 0x23), RGB(0x42, 0x27, 0x23), RGB(0x48, 0x2c, 0x2a), RGB(0x59, 0x43, 0x3c), RGB(0x62, 0x42, 0x44), RGB(0x79, 0x4c, 0x56), RGB(0xb3, 0x92, 0x9e), RGB(0xd7, 0xcc, 0xdb), RGB(0xb4, 0xa2, 0xb4), RGB(0xa9, 0x92, 0x9a), RGB(0xc5, 0xb0, 0xb9), RGB(0x9e, 0x86, 0x98), RGB(0x52, 0x2c, 0x35), RGB(0x45, 0x1f, 0x1e), RGB(0x5a, 0x37, 0x33), RGB(0x60, 0x3b, 0x3b), RGB(0x60, 0x43, 0x42), RGB(0x71, 0x58, 0x58), RGB(0x89, 0x76, 0x7b), RGB(0x98, 0x8b, 0x8d), RGB(0x84, 0x73, 0x69), RGB(0x80, 0x66, 0x55), RGB(0x94, 0x71, 0x61), RGB(0x9c, 0x80, 0x73), RGB(0x3d, 0x31, 0x2f), RGB(0x2b, 0x1d, 0x1b), RGB(0x3e, 0x26, 0x1d), RGB(0x42, 0x28, 0x1b), RGB(0x54, 0x2f, 0x24), RGB(0x54, 0x2f, 0x23), RGB(0x48, 0x2c, 0x1b), RGB(0x65, 0x50, 0x3d), RGB(0xb4, 0xab, 0xa6), RGB(0xa4, 0x9c, 0x9e), RGB(0x68, 0x5d, 0x57), RGB(0x5b, 0x53, 0x46)},
{RGB(0x21, 0x31, 0x34), RGB(0x1f, 0x36, 0x36), RGB(0x20, 0x39, 0x33), RGB(0x20, 0x2e, 0x2b), RGB(0x14, 0x11, 0x12), RGB(0x14, 0x14, 0x13), RGB(0x17, 0x16, 0x17), RGB(0x17, 0x17, 0x18), RGB(0x11, 0x10, 0x0d), RGB(0x39, 0x37, 0x34), RGB(0x5a, 0x56, 0x58), RGB(0x51, 0x47, 0x44), RGB(0x4d, 0x3d, 0x3b), RGB(0x48, 0x31, 0x2e), RGB(0x48, 0x2d, 0x28), RGB(0x43, 0x26, 0x25), RGB(0x50, 0x3a, 0x3b), RGB(0x5b, 0x46, 0x43), RGB(0x52, 0x36, 0x36), RGB(0x50, 0x2b, 0x2d), RGB(0x74, 0x53, 0x51), RGB(0x83, 0x70, 0x79), RGB(0x4e, 0x23, 0x2a), RGB(0x63, 0x38, 0x3e), RGB(0xa5, 0x91, 0xa4), RGB(0xb8, 0xb0, 0xca), RGB(0x8d, 0x78, 0x8c), RGB(0x49, 0x25, 0x26), RGB(0x36, 0x17, 0x17), RGB(0x49, 0x2b, 0x26), RGB(0x5a, 0x37, 0x32), RGB(0x62, 0x41, 0x3c), RGB(0x68, 0x4d, 0x4b), RGB(0x8d, 0x7f, 0x7d), RGB(0x9a, 0x8d, 0x89), RGB(0x96, 0x81, 0x79), RGB(0xa8, 0x86, 0x75), RGB(0x92, 0x72, 0x65), RGB(0x3f, 0x32, 0x30), RGB(0x30, 0x22, 0x1f), RGB(0x3b, 0x22, 0x1a), RGB(0x40, 0x26, 0x1d), RGB(0x53, 0x30, 0x23), RGB(0x4e, 0x2a, 0x1e), RGB(0x48, 0x2a, 0x1e), RGB(0x86, 0x69, 0x54), RGB(0xbf, 0xae, 0xa3), RGB(0x9d, 0x8b, 0x80), RGB(0x77, 0x66, 0x63), RGB(0x7d, 0x70, 0x6c)},
{RGB(0x1c, 0x32, 0x34), RGB(0x21, 0x35, 0x38), RGB(0x23, 0x33, 0x36), RGB(0x22, 0x35, 0x35), RGB(0x19, 0x1c, 0x19), RGB(0x13, 0x10, 0x0f), RGB(0x15, 0x16, 0x16), RGB(0x16, 0x16, 0x16), RGB(0x16, 0x16, 0x14), RGB(0x2e, 0x25, 0x1a), RGB(0x50, 0x4d, 0x4a), RGB(0x53, 0x4a, 0x4b), RGB(0x4d, 0x39, 0x39), RGB(0x4a, 0x34, 0x30), RGB(0x47, 0x2e, 0x2c), RGB(0x49, 0x30, 0x2e), RGB(0x50, 0x3f, 0x3d), RGB(0x52, 0x3a, 0x3a), RGB(0x53, 0x3c, 0x3b), RGB(0x54, 0x3c, 0x3a), RGB(0x48, 0x34, 0x2d), RGB(0x37, 0x1c, 0x1a), RGB(0x54, 0x33, 0x2f), RGB(0x9f, 0x93, 0x9f), RGB(0xb6, 0xb8, 0xc9), RGB(0xaf, 0xa8, 0xb6), RGB(0xab, 0xa0, 0xb0), RGB(0x77, 0x60, 0x62), RGB(0x3c, 0x1f, 0x1b), RGB(0x36, 0x20, 0x1a), RGB(0x45, 0x26, 0x1e), RGB(0x6b, 0x4d, 0x46), RGB(0x6f, 0x5a, 0x58), RGB(0x82, 0x70, 0x6c), RGB(0xa6, 0x96, 0x97), RGB(0xab, 0x9f, 0x9d), RGB(0xbf, 0xaa, 0x9e), RGB(0x80, 0x67, 0x61), RGB(0x2f, 0x23, 0x23), RGB(0x35, 0x27, 0x21), RGB(0x3b, 0x21, 0x1b), RGB(0x3b, 0x21, 0x1d), RGB(0x45, 0x27, 0x22), RGB(0x54, 0x35, 0x26), RGB(0x7d, 0x57, 0x45), RGB(0xa8, 0x8c, 0x7c), RGB(0xc3, 0xb7, 0xab), RGB(0xb5, 0xa4, 0x9e), RGB(0xbb, 0xb1, 0xad), RGB(0xb5, 0xa9, 0xa2)},
{RGB(0x1d, 0x31, 0x33), RGB(0x1f, 0x2e, 0x34), RGB(0x1f, 0x30, 0x30), RGB(0x22, 0x3a, 0x36), RGB(0x1e, 0x29, 0x26), RGB(0x14, 0x10, 0x0c), RGB(0x16, 0x16, 0x16), RGB(0x14, 0x15, 0x19), RGB(0x1e, 0x1d, 0x1a), RGB(0x2c, 0x1c, 0x0b), RGB(0x42, 0x3a, 0x30), RGB(0x58, 0x54, 0x53), RGB(0x4d, 0x3c, 0x38), RGB(0x47, 0x2f, 0x2a), RGB(0x40, 0x2b, 0x28), RGB(0x49, 0x38, 0x32), RGB(0x52, 0x42, 0x3e), RGB(0x53, 0x40, 0x3d), RGB(0x54, 0x40, 0x3c), RGB(0x50, 0x3e, 0x3c), RGB(0x4d, 0x3b, 0x35), RGB(0x59, 0x46, 0x46), RGB(0x64, 0x4f, 0x54), RGB(0x98, 0x88, 0x91), RGB(0xbb, 0xbc, 0xc8), RGB(0xbd, 0xbb, 0xc4), RGB(0xbb, 0xb9, 0xbe), RGB(0x95, 0x90, 0x95), RGB(0x50, 0x36, 0x36), RGB(0x3d, 0x22, 0x1b), RGB(0x4d, 0x30, 0x28), RGB(0x83, 0x70, 0x6f), RGB(0x94, 0x89, 0x88), RGB(0x86, 0x73, 0x73), RGB(0xad, 0x9f, 0xa4), RGB(0xbc, 0xb2, 0xb8), RGB(0xd3, 0xc7, 0xc4), RGB(0x5e, 0x54, 0x50), RGB(0x09, 0x04, 0x08), RGB(0x36, 0x26, 0x21), RGB(0x3e, 0x22, 0x1c), RGB(0x37, 0x1c, 0x17), RGB(0x4b, 0x37, 0x2d), RGB(0x75, 0x59, 0x4b), RGB(0x9a, 0x81, 0x6e), RGB(0xb4, 0xa9, 0xa7), RGB(0xc3, 0xc1, 0xc0), RGB(0xb1, 0xac, 0xa7), RGB(0xaf, 0xa2, 0x99), RGB(0xa7, 0x9b, 0x90)},
{RGB(0x1d, 0x25, 0x22), RGB(0x15, 0x22, 0x1f), RGB(0x1c, 0x28, 0x29), RGB(0x25, 0x37, 0x38), RGB(0x1f, 0x33, 0x2f), RGB(0x17, 0x15, 0x12), RGB(0x17, 0x16, 0x14), RGB(0x11, 0x15, 0x1b), RGB(0x26, 0x23, 0x1d), RGB(0x30, 0x26, 0x17), RGB(0x2c, 0x20, 0x16), RGB(0x50, 0x49, 0x46), RGB(0x55, 0x4c, 0x48), RGB(0x48, 0x35, 0x2f), RGB(0x41, 0x30, 0x28), RGB(0x42, 0x38, 0x31), RGB(0x4f, 0x45, 0x3d), RGB(0x54, 0x46, 0x3d), RGB(0x50, 0x3d, 0x38), RGB(0x4a, 0x39, 0x34), RGB(0x57, 0x3e, 0x3a), RGB(0x8c, 0x79, 0x82), RGB(0x8e, 0x83, 0x96), RGB(0x8d, 0x72, 0x7b), RGB(0xa4, 0x89, 0x93), RGB(0x9b, 0x85, 0x92), RGB(0x9f, 0x82, 0x95), RGB(0x8a, 0x6d, 0x82), RGB(0x5d, 0x45, 0x4f), RGB(0x43, 0x26, 0x23), RGB(0x57, 0x37, 0x34), RGB(0x95, 0x8d, 0x8e), RGB(0xa5, 0xa4, 0xa6), RGB(0x90, 0x80, 0x84), RGB(0xae, 0xa3, 0xa8), RGB(0xcd, 0xc5, 0xc5), RGB(0xc2, 0xbb, 0xbd), RGB(0x39, 0x2b, 0x2e), RGB(0x18, 0x09, 0x0c), RGB(0x34, 0x24, 0x21), RGB(0x41, 0x27, 0x1c), RGB(0x4b, 0x36, 0x2e), RGB(0x6b, 0x5d, 0x56), RGB(0x83, 0x6c, 0x5f), RGB(0x94, 0x83, 0x7f), RGB(0xb6, 0xb6, 0xbf), RGB(0x9c, 0x94, 0x95), RGB(0x9b, 0x95, 0x8b), RGB(0xb8, 0xb2, 0xa5), RGB(0xa8, 0x9f, 0x95)},
{RGB(0x1d, 0x2d, 0x2d), RGB(0x33, 0x43, 0x37), RGB(0x2a, 0x34, 0x2a), RGB(0x1e, 0x35, 0x35), RGB(0x22, 0x39, 0x36), RGB(0x1a, 0x1e, 0x1c), RGB(0x12, 0x11, 0x13), RGB(0x13, 0x18, 0x19), RGB(0x29, 0x26, 0x1f), RGB(0x31, 0x2e, 0x22), RGB(0x24, 0x1a, 0x0f), RGB(0x30, 0x27, 0x20), RGB(0x56, 0x55, 0x4c), RGB(0x52, 0x4a, 0x40), RGB(0x4c, 0x3b, 0x35), RGB(0x42, 0x30, 0x2a), RGB(0x42, 0x33, 0x2d), RGB(0x4b, 0x3d, 0x37), RGB(0x4d, 0x37, 0x34), RGB(0x4f, 0x36, 0x33), RGB(0x48, 0x2b, 0x2a), RGB(0x55, 0x36, 0x3a), RGB(0x63, 0x3f, 0x47), RGB(0x5d, 0x2d, 0x3a), RGB(0x70, 0x32, 0x4c), RGB(0x91, 0x5f, 0x7d), RGB(0xaa, 0x89, 0xa6), RGB(0xb5, 0xa2, 0xb6), RGB(0xa4, 0x9e, 0xa6), RGB(0x88, 0x7b, 0x81), RGB(0x60, 0x43, 0x43), RGB(0x87, 0x79, 0x79), RGB(0xa0, 0x99, 0x9e), RGB(0x98, 0x8a, 0x8f), RGB(0xaf, 0xa6, 0xaa), RGB(0xd9, 0xd2, 0xd2), RGB(0x7b, 0x74, 0x74), RGB(0x27, 0x13, 0x14), RGB(0x4b, 0x35, 0x31), RGB(0x3c, 0x29, 0x27), RGB(0x39, 0x2d, 0x27), RGB(0x70, 0x61, 0x5c), RGB(0x75, 0x61, 0x5d), RGB(0x75, 0x62, 0x5b), RGB(0x89, 0x7b, 0x7d), RGB(0x80, 0x7a, 0x7e), RGB(0x76, 0x6b, 0x6a), RGB(0xa4, 0xa1, 0xa2), RGB(0x8e, 0x8f, 0x8d), RGB(0x8c, 0x8c, 0x87)},
{RGB(0x1b, 0x3e, 0x4d), RGB(0x3c, 0x47, 0x47), RGB(0x31, 0x3a, 0x37), RGB(0x1d, 0x2e, 0x30), RGB(0x23, 0x3a, 0x38), RGB(0x1c, 0x28, 0x24), RGB(0x13, 0x0e, 0x12), RGB(0x18, 0x1a, 0x1a), RGB(0x28, 0x27, 0x21), RGB(0x2d, 0x2b, 0x21), RGB(0x2b, 0x27, 0x18), RGB(0x15, 0x0e, 0x06), RGB(0x3a, 0x2f, 0x2b), RGB(0x61, 0x55, 0x4e), RGB(0x55, 0x46, 0x43), RGB(0x49, 0x34, 0x2c), RGB(0x43, 0x2f, 0x27), RGB(0x4a, 0x37, 0x33), RGB(0x48, 0x30, 0x30), RGB(0x45, 0x28, 0x2e), RGB(0x39, 0x18, 0x1f), RGB(0x37, 0x0f, 0x13), RGB(0x54, 0x21, 0x30), RGB(0x7d, 0x41, 0x5c), RGB(0xa7, 0x6c, 0x8f), RGB(0xbf, 0xa1, 0xb5), RGB(0xc5, 0xc4, 0xca), RGB(0xc3, 0xc5, 0xc9), RGB(0xb5, 0xaf, 0xb5), RGB(0xbd, 0xbb, 0xc3), RGB(0x9b, 0x94, 0x97), RGB(0x8a, 0x78, 0x79), RGB(0x91, 0x7f, 0x81), RGB(0x99, 0x85, 0x88), RGB(0xc3, 0xbc, 0xbf), RGB(0xaa, 0xa5, 0xa6), RGB(0x3a, 0x29, 0x26), RGB(0x3c, 0x2c, 0x26), RGB(0x49, 0x37, 0x33), RGB(0x41, 0x34, 0x33), RGB(0x5c, 0x55, 0x53), RGB(0x91, 0x81, 0x7f), RGB(0x82, 0x6c, 0x5f), RGB(0x61, 0x48, 0x3f), RGB(0x55, 0x46, 0x3e), RGB(0x4e, 0x3f, 0x37), RGB(0x73, 0x68, 0x6c), RGB(0x60, 0x5a, 0x5e), RGB(0x55, 0x58, 0x5d), RGB(0x85, 0x8f, 0x99)},
{RGB(0x28, 0x50, 0x78), RGB(0x26, 0x37, 0x3b), RGB(0x36, 0x45, 0x42), RGB(0x24, 0x2f, 0x32), RGB(0x21, 0x36, 0x3b), RGB(0x20, 0x2f, 0x32), RGB(0x13, 0x14, 0x13), RGB(0x1a, 0x1c, 0x19), RGB(0x29, 0x27, 0x22), RGB(0x2b, 0x26, 0x1f), RGB(0x2c, 0x23, 0x17), RGB(0x1c, 0x17, 0x0d), RGB(0x10, 0x09, 0x07), RGB(0x42, 0x37, 0x35), RGB(0x5f, 0x55, 0x4b), RGB(0x50, 0x3f, 0x38), RGB(0x52, 0x42, 0x3a), RGB(0x57, 0x46, 0x41), RGB(0x58, 0x46, 0x44), RGB(0x50, 0x3f, 0x40), RGB(0x50, 0x35, 0x32), RGB(0x5c, 0x30, 0x39), RGB(0x6e, 0x45, 0x54), RGB(0x7a, 0x52, 0x5e), RGB(0x8e, 0x72, 0x7b), RGB(0xa8, 0x9e, 0xa5), RGB(0xb9, 0xb6, 0xb9), RGB(0xb8, 0xb5, 0xba), RGB(0xb4, 0xaa, 0xb3), RGB(0xc5, 0xc5, 0xca), RGB(0xc9, 0xcb, 0xcf), RGB(0x9f, 0x92, 0x92), RGB(0x8b, 0x71, 0x75), RGB(0xaa, 0x9c, 0x9a), RGB(0xbd, 0xbb, 0xbb), RGB(0x4f, 0x41, 0x3d), RGB(0x26, 0x19, 0x15), RGB(0x58, 0x52, 0x51), RGB(0x7d, 0x75, 0x6f), RGB(0x95, 0x8a, 0x7b), RGB(0xa6, 0x95, 0x87), RGB(0x9e, 0x8f, 0x8b), RGB(0x69, 0x56, 0x49), RGB(0x38, 0x26, 0x1c), RGB(0x44, 0x36, 0x2f), RGB(0x4f, 0x44, 0x3d), RGB(0x36, 0x31, 0x31), RGB(0x20, 0x22, 0x25), RGB(0x4c, 0x5a, 0x6b), RGB(0x7c, 0x86, 0x89)},
{RGB(0x1e, 0x4c, 0x7c), RGB(0x25, 0x3c, 0x4f), RGB(0x3d, 0x4b, 0x4a), RGB(0x2c, 0x3a, 0x37), RGB(0x1f, 0x32, 0x31), RGB(0x22, 0x38, 0x36), RGB(0x15, 0x1f, 0x1f), RGB(0x17, 0x15, 0x15), RGB(0x26, 0x27, 0x1e), RGB(0x2c, 0x27, 0x1d), RGB(0x29, 0x1f, 0x15), RGB(0x22, 0x1c, 0x10), RGB(0x0b, 0x0b, 0x07), RGB(0x06, 0x07, 0x05), RGB(0x44, 0x3b, 0x33), RGB(0x61, 0x4f, 0x4a), RGB(0x57, 0x47, 0x45), RGB(0x57, 0x45, 0x41), RGB(0x55, 0x44, 0x3f), RGB(0x56, 0x46, 0x3f), RGB(0x54, 0x47, 0x3d), RGB(0x4f, 0x3a, 0x3d), RGB(0x4a, 0x36, 0x30), RGB(0x55, 0x40, 0x3d), RGB(0x5c, 0x4c, 0x4e), RGB(0x80, 0x70, 0x76), RGB(0xa8, 0x9c, 0xa7), RGB(0xab, 0xa2, 0xa8), RGB(0xb3, 0xac, 0xb0), RGB(0xc9, 0xc7, 0xcd), RGB(0xce, 0xce, 0xd2), RGB(0xa9, 0x9f, 0x9f), RGB(0xa0, 0x90, 0x91), RGB(0xac, 0xac, 0xad), RGB(0x63, 0x5a, 0x59), RGB(0x4b, 0x36, 0x30), RGB(0x89, 0x81, 0x7d), RGB(0xc4, 0xc0, 0xbc), RGB(0xd8, 0xd3, 0xc9), RGB(0xc7, 0xbe, 0xb1), RGB(0xb4, 0xa7, 0x9c), RGB(0x6f, 0x5a, 0x4e), RGB(0x24, 0x16, 0x11), RGB(0x31, 0x2c, 0x29), RGB(0x46, 0x3f, 0x3e), RGB(0x29, 0x2a, 0x2a), RGB(0x11, 0x15, 0x11), RGB(0x24, 0x35, 0x48), RGB(0x3f, 0x52, 0x69), RGB(0x65, 0x64, 0x5b)},
{RGB(0x24, 0x5f, 0x93), RGB(0x17, 0x3a, 0x5e), RGB(0x35, 0x44, 0x49), RGB(0x32, 0x3f, 0x42), RGB(0x20, 0x33, 0x2d), RGB(0x23, 0x3e, 0x37), RGB(0x21, 0x2a, 0x30), RGB(0x18, 0x13, 0x12), RGB(0x20, 0x20, 0x19), RGB(0x26, 0x21, 0x18), RGB(0x26, 0x1d, 0x12), RGB(0x1c, 0x19, 0x10), RGB(0x13, 0x12, 0x0a), RGB(0x03, 0x02, 0x01), RGB(0x05, 0x02, 0x02), RGB(0x39, 0x33, 0x2c), RGB(0x5e, 0x53, 0x4b), RGB(0x5a, 0x4c, 0x42), RGB(0x50, 0x41, 0x3c), RGB(0x4f, 0x3c, 0x37), RGB(0x4d, 0x39, 0x31), RGB(0x46, 0x35, 0x2f), RGB(0x52, 0x3f, 0x38), RGB(0x64, 0x4f, 0x54), RGB(0x6c, 0x59, 0x62), RGB(0x83, 0x76, 0x7a), RGB(0xa0, 0x94, 0x9b), RGB(0xa7, 0x9f, 0xa3), RGB(0xb5, 0xb5, 0xb8), RGB(0xcb, 0xc7, 0xce), RGB(0xc7, 0xc6, 0xcb), RGB(0xb5, 0xb4, 0xb6), RGB(0xae, 0xad, 0xa9), RGB(0x82, 0x7a, 0x77), RGB(0x62, 0x50, 0x4a), RGB(0x99, 0x83, 0x77), RGB(0xb3, 0x9f, 0x8c), RGB(0xba, 0xa8, 0x95), RGB(0xbe, 0xae, 0x9c), RGB(0xc5, 0xb5, 0x9d), RGB(0x9a, 0x82, 0x68), RGB(0x33, 0x23, 0x1a), RGB(0x1c, 0x1c, 0x1f), RGB(0x3e, 0x3b, 0x35), RGB(0x25, 0x29, 0x31), RGB(0x12, 0x18, 0x1f), RGB(0x10, 0x13, 0x16), RGB(0x30, 0x45, 0x66), RGB(0x3d, 0x45, 0x51), RGB(0x55, 0x5b, 0x5c)},
{RGB(0xa2, 0xc9, 0xe2), RGB(0x31, 0x5c, 0x8b), RGB(0x15, 0x2f, 0x41), RGB(0x3b, 0x4b, 0x4a), RGB(0x2f, 0x40, 0x43), RGB(0x22, 0x36, 0x37), RGB(0x15, 0x1e, 0x1d), RGB(0x19, 0x18, 0x18), RGB(0x1c, 0x1a, 0x19), RGB(0x1d, 0x1a, 0x13), RGB(0x24, 0x1e, 0x12), RGB(0x1a, 0x17, 0x0e), RGB(0x11, 0x10, 0x07), RGB(0x0c, 0x0a, 0x08), RGB(0x20, 0x20, 0x02), RGB(0x20, 0x20, 0x20), RGB(0x2f, 0x28, 0x23), RGB(0x5d, 0x50, 0x46), RGB(0x59, 0x48, 0x45), RGB(0x4e, 0x3c, 0x33), RGB(0x4f, 0x3c, 0x2e), RGB(0x60, 0x4e, 0x4a), RGB(0x7f, 0x72, 0x76), RGB(0x9c, 0x91, 0x98), RGB(0xb5, 0xaf, 0xba), RGB(0xb1, 0xac, 0xb6), RGB(0xa2, 0x97, 0x9b), RGB(0xae, 0xa5, 0xac), RGB(0xc4, 0xbc, 0xc5), RGB(0xc8, 0xc7, 0xcc), RGB(0xb8, 0xba, 0xbe), RGB(0x9e, 0x9d, 0xa0), RGB(0x7e, 0x6e, 0x65), RGB(0x7a, 0x5f, 0x49), RGB(0x96, 0x7c, 0x65), RGB(0x90, 0x76, 0x64), RGB(0x89, 0x6b, 0x56), RGB(0x8c, 0x6e, 0x5a), RGB(0x92, 0x75, 0x5e), RGB(0x80, 0x66, 0x4d), RGB(0x41, 0x32, 0x1f), RGB(0x21, 0x1d, 0x1e), RGB(0x33, 0x34, 0x39), RGB(0x2e, 0x33, 0x31), RGB(0x12, 0x1d, 0x2b), RGB(0x0d, 0x0f, 0x13), RGB(0x13, 0x1b, 0x23), RGB(0x2b, 0x4a, 0x65), RGB(0x45, 0x48, 0x52), RGB(0x42, 0x50, 0x6c)},
{RGB(0xd5, 0xf7, 0xe8), RGB(0x97, 0xd2, 0xe3), RGB(0x20, 0x45, 0x66), RGB(0x28, 0x3b, 0x3d), RGB(0x1d, 0x2e, 0x35), RGB(0x09, 0x13, 0x19), RGB(0x09, 0x0e, 0x0b), RGB(0x1b, 0x1b, 0x17), RGB(0x16, 0x15, 0x10), RGB(0x1b, 0x1a, 0x0d), RGB(0x21, 0x1d, 0x0f), RGB(0x18, 0x16, 0x0d), RGB(0x11, 0x0f, 0x07), RGB(0x08, 0x08, 0x07), RGB(0x07, 0x07, 0x08), RGB(0x01, 0x01, 0x02), RGB(0x20, 0x20, 0x20), RGB(0x22, 0x20, 0x19), RGB(0x58, 0x49, 0x41), RGB(0x5b, 0x47, 0x42), RGB(0x52, 0x41, 0x3d), RGB(0x66, 0x51, 0x52), RGB(0x77, 0x66, 0x66), RGB(0x87, 0x73, 0x77), RGB(0xa6, 0x95, 0xa1), RGB(0xb9, 0xb1, 0xb9), RGB(0xb2, 0xaa, 0xae), RGB(0xc0, 0xb6, 0xbf), RGB(0xbe, 0xb7, 0xbe), RGB(0xa3, 0x9f, 0xa6), RGB(0x7e, 0x79, 0x79), RGB(0x66, 0x53, 0x45), RGB(0x70, 0x4d, 0x38), RGB(0x78, 0x58, 0x40), RGB(0x73, 0x51, 0x38), RGB(0x81, 0x69, 0x51), RGB(0x9e, 0x8b, 0x7b), RGB(0x9d, 0x8c, 0x7d), RGB(0x74, 0x62, 0x4f), RGB(0x4c, 0x43, 0x3b), RGB(0x31, 0x2f, 0x2e), RGB(0x3e, 0x3a, 0x35), RGB(0x23, 0x23, 0x21), RGB(0x18, 0x26, 0x38), RGB(0x13, 0x22, 0x2b), RGB(0x0a, 0x0b, 0x03), RGB(0x1e, 0x2d, 0x40), RGB(0x29, 0x3c, 0x5c), RGB(0x33, 0x40, 0x4e), RGB(0x29, 0x45, 0x5d)},
{RGB(0xb4, 0xdf, 0xe2), RGB(0x86, 0xbd, 0xd7), RGB(0x26, 0x3f, 0x58), RGB(0x01, 0x0b, 0x17), RGB(0x03, 0x0f, 0x16), RGB(0x07, 0x08, 0x0c), RGB(0x12, 0x15, 0x12), RGB(0x16, 0x17, 0x0f), RGB(0x10, 0x11, 0x09), RGB(0x18, 0x16, 0x0e), RGB(0x1e, 0x1a, 0x0e), RGB(0x17, 0x16, 0x0a), RGB(0x0f, 0x0e, 0x06), RGB(0x07, 0x07, 0x04), RGB(0x06, 0x06, 0x07), RGB(0x07, 0x07, 0x07), RGB(0x03, 0x03, 0x05), RGB(0x20, 0x20, 0x20), RGB(0x17, 0x15, 0x0e), RGB(0x52, 0x3e, 0x38), RGB(0x61, 0x4a, 0x46), RGB(0x56, 0x43, 0x42), RGB(0x53, 0x41, 0x3d), RGB(0x5d, 0x47, 0x48), RGB(0x7f, 0x67, 0x70), RGB(0xa5, 0x95, 0x9c), RGB(0xb9, 0xb0, 0xbe), RGB(0xae, 0xa8, 0xb4), RGB(0x82, 0x79, 0x7b), RGB(0x7a, 0x72, 0x6d), RGB(0x78, 0x66, 0x57), RGB(0x6e, 0x49, 0x31), RGB(0x81, 0x60, 0x46), RGB(0x88, 0x6a, 0x4e), RGB(0x92, 0x71, 0x58), RGB(0xa9, 0x9b, 0x81), RGB(0xb5, 0xad, 0x9b), RGB(0xa3, 0x98, 0x87), RGB(0x63, 0x58, 0x4d), RGB(0x37, 0x37, 0x33), RGB(0x2e, 0x2d, 0x2b), RGB(0x25, 0x23, 0x1f), RGB(0x12, 0x19, 0x28), RGB(0x15, 0x2a, 0x40), RGB(0x0c, 0x18, 0x18), RGB(0x0c, 0x0d, 0x07), RGB(0x23, 0x39, 0x58), RGB(0x1c, 0x2f, 0x4a), RGB(0x1c, 0x2b, 0x33), RGB(0x1a, 0x29, 0x32)},
{RGB(0x2e, 0x43, 0x5e), RGB(0x07, 0x13, 0x2c), RGB(0x03, 0x0e, 0x11), RGB(0x07, 0x0e, 0x0f), RGB(0x09, 0x0c, 0x0e), RGB(0x0a, 0x0b, 0x0d), RGB(0x11, 0x15, 0x11), RGB(0x0f, 0x10, 0x0c), RGB(0x0b, 0x0c, 0x08), RGB(0x16, 0x15, 0x0b), RGB(0x1c, 0x17, 0x0d), RGB(0x14, 0x12, 0x0a), RGB(0x0c, 0x0c, 0x06), RGB(0x06, 0x06, 0x03), RGB(0x05, 0x05, 0x06), RGB(0x06, 0x06, 0x06), RGB(0x06, 0x06, 0x06), RGB(0x06, 0x06, 0x07), RGB(0x20, 0x20, 0x20), RGB(0x0e, 0x0d, 0x07), RGB(0x3b, 0x30, 0x29), RGB(0x52, 0x3e, 0x3a), RGB(0x53, 0x3c, 0x36), RGB(0x50, 0x38, 0x33), RGB(0x5c, 0x42, 0x42), RGB(0x77, 0x61, 0x64), RGB(0x80, 0x6f, 0x70), RGB(0x6a, 0x52, 0x48), RGB(0x68, 0x4b, 0x39), RGB(0x92, 0x78, 0x5d), RGB(0x9f, 0x80, 0x60), RGB(0x7b, 0x52, 0x3a), RGB(0x65, 0x3f, 0x28), RGB(0x76, 0x55, 0x38), RGB(0xaa, 0x97, 0x76), RGB(0xd2, 0xc8, 0xb0), RGB(0xc0, 0xb8, 0x9c), RGB(0x7e, 0x70, 0x50), RGB(0x38, 0x2e, 0x1c), RGB(0x22, 0x24, 0x18), RGB(0x1c, 0x1c, 0x19), RGB(0x10, 0x14, 0x14), RGB(0x19, 0x27, 0x3c), RGB(0x13, 0x23, 0x35), RGB(0x0c, 0x0c, 0x05), RGB(0x15, 0x1b, 0x21), RGB(0x1f, 0x38, 0x59), RGB(0x14, 0x21, 0x2b), RGB(0x0e, 0x19, 0x1b), RGB(0x19, 0x2a, 0x43)},
{RGB(0x20, 0x04, 0x09), RGB(0x08, 0x09, 0x0b), RGB(0x09, 0x10, 0x0e), RGB(0x07, 0x0b, 0x0c), RGB(0x08, 0x09, 0x0d), RGB(0x0b, 0x0c, 0x0d), RGB(0x11, 0x10, 0x10), RGB(0x0d, 0x0c, 0x0d), RGB(0x07, 0x08, 0x08), RGB(0x12, 0x12, 0x0c), RGB(0x1a, 0x17, 0x0b), RGB(0x13, 0x10, 0x09), RGB(0x09, 0x08, 0x08), RGB(0x04, 0x04, 0x05), RGB(0x04, 0x04, 0x04), RGB(0x05, 0x05, 0x05), RGB(0x05, 0x05, 0x05), RGB(0x07, 0x06, 0x06), RGB(0x0a, 0x0a, 0x0a), RGB(0x02, 0x05, 0x05), RGB(0x20, 0x02, 0x03), RGB(0x14, 0x10, 0x11), RGB(0x28, 0x1d, 0x19), RGB(0x31, 0x24, 0x20), RGB(0x32, 0x21, 0x21), RGB(0x31, 0x1e, 0x15), RGB(0x3d, 0x23, 0x0c), RGB(0x50, 0x29, 0x11), RGB(0x5e, 0x36, 0x1c), RGB(0x63, 0x3d, 0x23), RGB(0x62, 0x41, 0x27), RGB(0x52, 0x32, 0x1b), RGB(0x41, 0x1e, 0x0f), RGB(0x4c, 0x30, 0x1c), RGB(0x83, 0x6d, 0x52), RGB(0xc1, 0xb2, 0x89), RGB(0xab, 0x9f, 0x74), RGB(0x58, 0x45, 0x2b), RGB(0x2e, 0x25, 0x17), RGB(0x1f, 0x20, 0x19), RGB(0x12, 0x13, 0x10), RGB(0x12, 0x1b, 0x22), RGB(0x19, 0x31, 0x47), RGB(0x0f, 0x1b, 0x1f), RGB(0x09, 0x09, 0x03), RGB(0x16, 0x28, 0x3e), RGB(0x15, 0x2b, 0x40), RGB(0x0d, 0x11, 0x0e), RGB(0x12, 0x23, 0x31), RGB(0x2e, 0x53, 0x79)},
{RGB(0x08, 0x0f, 0x10), RGB(0x0a, 0x0c, 0x0e), RGB(0x08, 0x09, 0x0c), RGB(0x05, 0x07, 0x09), RGB(0x03, 0x05, 0x08), RGB(0x0b, 0x0c, 0x0d), RGB(0x0e, 0x0e, 0x0d), RGB(0x0a, 0x0a, 0x0b), RGB(0x09, 0x09, 0x09), RGB(0x11, 0x12, 0x09), RGB(0x17, 0x15, 0x08), RGB(0x12, 0x0f, 0x08), RGB(0x0a, 0x09, 0x09), RGB(0x04, 0x04, 0x06), RGB(0x03, 0x03, 0x04), RGB(0x05, 0x05, 0x05), RGB(0x05, 0x05, 0x05), RGB(0x07, 0x07, 0x07), RGB(0x07, 0x06, 0x07), RGB(0x0c, 0x0b, 0x0c), RGB(0x0a, 0x0b, 0x0c), RGB(0x02, 0x05, 0x05), RGB(0x04, 0x05, 0x02), RGB(0x0d, 0x0e, 0x07), RGB(0x1d, 0x17, 0x0e), RGB(0x26, 0x17, 0x06), RGB(0x37, 0x25, 0x0c), RGB(0x41, 0x27, 0x15), RGB(0x3a, 0x1c, 0x0d), RGB(0x3b, 0x21, 0x11), RGB(0x40, 0x2a, 0x1f), RGB(0x2d, 0x14, 0x0f), RGB(0x2b, 0x18, 0x0c), RGB(0x2d, 0x1d, 0x11), RGB(0x3e, 0x2e, 0x22), RGB(0x52, 0x45, 0x32), RGB(0x62, 0x55, 0x36), RGB(0x59, 0x49, 0x30), RGB(0x30, 0x2d, 0x1e), RGB(0x13, 0x15, 0x13), RGB(0x0c, 0x0e, 0x0f), RGB(0x16, 0x28, 0x33), RGB(0x14, 0x2d, 0x44), RGB(0x0b, 0x10, 0x0f), RGB(0x0b, 0x11, 0x12), RGB(0x11, 0x26, 0x34), RGB(0x0d, 0x14, 0x1b), RGB(0x0b, 0x12, 0x10), RGB(0x23, 0x40, 0x57), RGB(0x32, 0x5a, 0x7f)},
{RGB(0x0c, 0x0c, 0x11), RGB(0x08, 0x09, 0x0d), RGB(0x05, 0x07, 0x0b), RGB(0x05, 0x06, 0x08), RGB(0x06, 0x06, 0x04), RGB(0x0a, 0x0a, 0x0b), RGB(0x0c, 0x0d, 0x0d), RGB(0x08, 0x08, 0x09), RGB(0x0a, 0x09, 0x0a), RGB(0x0f, 0x11, 0x09), RGB(0x12, 0x12, 0x09), RGB(0x11, 0x0e, 0x09), RGB(0x0d, 0x0d, 0x06), RGB(0x06, 0x07, 0x04), RGB(0x04, 0x04, 0x05), RGB(0x06, 0x06, 0x05), RGB(0x05, 0x05, 0x06), RGB(0x07, 0x07, 0x08), RGB(0x07, 0x07, 0x07), RGB(0x08, 0x08, 0x09), RGB(0x0a, 0x0a, 0x0b), RGB(0x10, 0x0f, 0x0b), RGB(0x15, 0x12, 0x0c), RGB(0x18, 0x15, 0x0d), RGB(0x2a, 0x21, 0x10), RGB(0x2b, 0x1d, 0x0d), RGB(0x28, 0x1d, 0x0b), RGB(0x25, 0x1c, 0x0e), RGB(0x24, 0x1c, 0x10), RGB(0x2c, 0x23, 0x16), RGB(0x2b, 0x1f, 0x15), RGB(0x21, 0x18, 0x0e), RGB(0x1e, 0x1b, 0x0e), RGB(0x17, 0x16, 0x0f), RGB(0x0e, 0x0e, 0x0a), RGB(0x08, 0x08, 0x04), RGB(0x15, 0x10, 0x06), RGB(0x3e, 0x2f, 0x23), RGB(0x25, 0x23, 0x1c), RGB(0x0c, 0x10, 0x0b), RGB(0x12, 0x15, 0x19), RGB(0x17, 0x2c, 0x40), RGB(0x11, 0x23, 0x31), RGB(0x09, 0x07, 0x07), RGB(0x0f, 0x15, 0x1a), RGB(0x12, 0x1a, 0x1a), RGB(0x09, 0x08, 0x02), RGB(0x11, 0x28, 0x3e), RGB(0x2c, 0x53, 0x7b), RGB(0x21, 0x42, 0x5e)},
{RGB(0x08, 0x0c, 0x0d), RGB(0x07, 0x0b, 0x0b), RGB(0x03, 0x06, 0x0a), RGB(0x03, 0x05, 0x07), RGB(0x05, 0x05, 0x05), RGB(0x08, 0x08, 0x07), RGB(0x0e, 0x0e, 0x0c), RGB(0x0b, 0x0b, 0x09), RGB(0x08, 0x08, 0x06), RGB(0x0c, 0x0c, 0x0b), RGB(0x0f, 0x0f, 0x0c), RGB(0x11, 0x0e, 0x0a), RGB(0x11, 0x10, 0x07), RGB(0x0b, 0x0b, 0x05), RGB(0x05, 0x04, 0x05), RGB(0x05, 0x05, 0x05), RGB(0x07, 0x07, 0x05), RGB(0x07, 0x07, 0x05), RGB(0x07, 0x07, 0x05), RGB(0x08, 0x08, 0x05), RGB(0x08, 0x08, 0x07), RGB(0x0f, 0x0f, 0x0b), RGB(0x16, 0x17, 0x0d), RGB(0x16, 0x14, 0x0c), RGB(0x1e, 0x16, 0x0b), RGB(0x1f, 0x19, 0x0f), RGB(0x19, 0x16, 0x12), RGB(0x19, 0x18, 0x0e), RGB(0x1c, 0x19, 0x12), RGB(0x19, 0x18, 0x12), RGB(0x19, 0x19, 0x11), RGB(0x19, 0x1b, 0x11), RGB(0x1e, 0x19, 0x11), RGB(0x12, 0x11, 0x0b), RGB(0x0b, 0x0d, 0x0a), RGB(0x0f, 0x0f, 0x0a), RGB(0x16, 0x15, 0x0f), RGB(0x1a, 0x1a, 0x12), RGB(0x10, 0x13, 0x0f), RGB(0x0b, 0x0e, 0x0c), RGB(0x14, 0x1e, 0x28), RGB(0x14, 0x27, 0x3c), RGB(0x0f, 0x14, 0x16), RGB(0x09, 0x07, 0x07), RGB(0x0c, 0x12, 0x18), RGB(0x0a, 0x0b, 0x0b), RGB(0x0a, 0x11, 0x15), RGB(0x18, 0x37, 0x54), RGB(0x1c, 0x3b, 0x61), RGB(0x15, 0x29, 0x44)}
};
#define AlexB *Alex_B

const PROGMEM uint8_t icon_Settings[] = {	//24*24 mono
	0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x3c, 0x00, 0x06, 0x7e, 0x60,
	0x0f, 0xff, 0xf0, 0x1f, 0xff, 0xf8, 0x1f, 0xff, 0xf8, 0x0f, 0xff, 0xf0,
	0x0f, 0xc3, 0xf0, 0x1f, 0x81, 0xf8, 0x7f, 0x00, 0xfe, 0x7f, 0x00, 0xfe,
	0x7f, 0x00, 0xfe, 0x7f, 0x00, 0xfe, 0x1f, 0x81, 0xf8, 0x0f, 0xc3, 0xf0,
	0x0f, 0xff, 0xf0, 0x1f, 0xff, 0xf8, 0x1f, 0xff, 0xf8, 0x0f, 0xff, 0xf0,
	0x06, 0x7e, 0x60, 0x00, 0x3c, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00
	//32*32 mono
	/*0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0x80, 0x07, 0x00, 0x0f, 0xc0, 0x03, 0x80, 0x07, 0xe0,
	0x03, 0x80, 0x03, 0xf0, 0x47, 0x80, 0x01, 0xf8, 0x7f, 0xc0, 0x03, 0xfc, 0x3f, 0xe0, 0x07, 0xfe,
	0x1f, 0xf0, 0x0f, 0xff, 0x03, 0xf8, 0x1f, 0xdf, 0x01, 0xfc, 0x3f, 0x8e, 0x00, 0xfe, 0x7f, 0x04,
	0x00, 0x7f, 0xfe, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00,
	0x00, 0x0f, 0xf0, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x7f, 0xfe, 0x00,
	0x00, 0xfe, 0x7f, 0x00, 0x01, 0xfc, 0x3f, 0x80, 0x03, 0xf8, 0x1f, 0xc0, 0x07, 0xf0, 0x0f, 0xf8,
	0x0f, 0xe0, 0x07, 0xfc, 0x1f, 0xc0, 0x03, 0xce, 0x3f, 0x80, 0x01, 0x86, 0x7f, 0x00, 0x01, 0x86,
	0x7e, 0x00, 0x01, 0xce, 0x7c, 0x00, 0x00, 0xfc, 0x78, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00*/
};

const PROGMEM uint8_t icon_Clock[] = {		//24*24 mono
	0x00, 0x7e, 0x00, 0x01, 0xff, 0x80, 0x07, 0xff, 0xe0, 0x0f, 0x81, 0xf0,
	0x1e, 0x18, 0x78, 0x3c, 0x18, 0x3c, 0x38, 0x18, 0x1e, 0x70, 0x18, 0x0e,
	0x70, 0x18, 0x0e, 0xe0, 0x18, 0x07, 0xe0, 0x18, 0x07, 0xe0, 0x1f, 0xc7,
	0xe0, 0x1f, 0xc7, 0xe0, 0x00, 0x07, 0xe0, 0x00, 0x07, 0x70, 0x00, 0x0e,
	0x70, 0x00, 0x0e, 0x38, 0x00, 0x1e, 0x3c, 0x00, 0x3c, 0x1e, 0x00, 0x78,
	0x0f, 0x81, 0xf0, 0x07, 0xff, 0xe0, 0x03, 0xff, 0xc0, 0x00, 0x7e, 0x00
	//32*32 mono
	/*0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0xff, 0xff, 0x00,
	0x03, 0xff, 0xff, 0xc0, 0x07, 0xf8, 0x1f, 0xe0, 0x0f, 0xe1, 0x87, 0xf0, 0x0f, 0x81, 0x81, 0xf0,
	0x1f, 0x01, 0x80, 0xf8, 0x1e, 0x01, 0x80, 0x78, 0x3e, 0x01, 0x80, 0x7c, 0x3c, 0x01, 0x80, 0x3c,
	0x7c, 0x01, 0x80, 0x3e, 0x78, 0x01, 0x80, 0x1e, 0x78, 0x01, 0x80, 0x1e, 0x78, 0x01, 0xfe, 0x1e,
	0x78, 0x01, 0xfe, 0x1e, 0x78, 0x00, 0x00, 0x1e, 0x78, 0x00, 0x00, 0x1e, 0x7c, 0x00, 0x00, 0x3e,
	0x3c, 0x00, 0x00, 0x3c, 0x3e, 0x00, 0x00, 0x7c, 0x1e, 0x00, 0x00, 0x78, 0x1f, 0x00, 0x00, 0xf8,
	0x0f, 0x80, 0x01, 0xf0, 0x0f, 0xe0, 0x07, 0xf0, 0x07, 0xf8, 0x1f, 0xe0, 0x03, 0xff, 0xff, 0xc0,
	0x00, 0xff, 0xff, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00*/
};

/*not used yet		const PROGMEM uint8_t icon_Calend[] {		//24*24 mono
	0x7f, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x03,
	0xc2, 0x9c, 0xc3, 0xc5, 0x51, 0x23, 0xc5, 0x59, 0x03, 0xc5, 0x51, 0x23,
	0xc5, 0x5c, 0xc3, 0xc0, 0x00, 0x03, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x03,
	0xc0, 0x54, 0xa3, 0xc0, 0x00, 0x03, 0xc5, 0x54, 0xa3, 0xc0, 0x00, 0x03, 
	0xc5, 0x54, 0xa3, 0xc0, 0x00, 0x03, 0xc5, 0x54, 0xa3, 0xc0, 0x00, 0x03,
	0xc5, 0x50, 0x03, 0xc0, 0x00, 0x03, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xfe
};*/

/*not used yet		const PROGMEM uint8_t icon_Ringer[] = {		//24*24 mono
	0x00, 0x00, 0x10, 0x00, 0x00, 0x28, 0x00, 0x00, 0x10, 0x00, 0x00, 0x70,
	0x00, 0x00, 0xf0, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x60, 0x20, 0x1c, 0x60,
	0x50, 0x38, 0x60, 0xa8, 0x60, 0x60, 0x51, 0xc0, 0x60, 0xa3, 0x80, 0x60,
	0x4e, 0x00, 0x60, 0x1c, 0x00, 0xc0, 0x78, 0x00, 0xc0, 0xff, 0x80, 0xc0,
	0x47, 0xe0, 0xc0, 0x3f, 0x70, 0xc0, 0x1e, 0x18, 0xca, 0x1e, 0x0c, 0xd4,
	0x0d, 0x07, 0xca, 0x00, 0xe3, 0x94, 0x00, 0x19, 0x80, 0x00, 0x07, 0x80
};*/

//not used yet		const PROGMEM uint8_t icon_mini_NoComp[] = {	0xf0, 0x90, 0x90, 0xf0, 0x00, 0xf5, 0x02, 0x05 };	//8*8 mono
//not uset yet		const PROGMEM uint8_t icon_mini_Ringer[] = {	0x18, 0x24, 0x24, 0x24, 0x42, 0x81, 0xff, 0x0c };	//8*8 mono

const PROGMEM char stringtable[17][24] = { // !!! вручную [количество строк][длина самой длинной строки+1]
//0
	"Arduino Assistant",										//used: showSummary()
	"\xa2\xaf\xb2\xab\xb1\xa5\xb2\xa5\xae\xbd\xa5",	// воскресенье		class clocks
	"\xb0\xaf\xae\xa5\xa4\xa5\xac\xbd\xae\xa9\xab",	// понедельник		==
	"\xa2\xb3\xaf\xb1\xae\xa9\xab",				// вторник		==
	"\xb2\xb1\xa5\xa4\xa0",						// среда			==
	"\xb8\xa5\xb3\xa2\xa5\xb1\xa3",				// четверг		==
	"\xb0\xc0\xb3\xae\xa9\xb7\xa0",				// пятница		==
	"\xb2\xb4\xa1\xa1\xaf\xb3\xa0",				// суббота		==
	"\x83\xac\xa0\xa2\xae\xaf\xa5 \xad\xa5\xae\xbf",	// Главное меню	showMMenu()
	"\x8d\xa0\xb2\xb3\xb1\xaf\xaa\xab\xa9",			// Настройки		showMMenu(), showSettings()
//10
	"\x8d\xa0\xb2\xb3\xb1\xaf\xaa\xab\xa9 \xbe\xab\xb1\xa0\xae\xa0",		// Настройки экрана		showSettings(), showSettingsScreen()
	"\x93\xb1\xaf\xa2\xa5\xae\xbd \xb0\xaf\xa4\xb2\xa2\xa5\xb3\xab\xa9",	// Уровень подсветки	showSettingsScreen(), showSettingsScreenBacklight()
	"\x96\xa2\xa5\xb3 \xb3\xa5\xab\xb2\xb3\xa0",						// Цвет текста			showSettingsScreen(), showSettingsScreenTColor()
	"\x96\xa2\xa5\xb3 \xb5\xaf\xae\xa0",							// Цвет фона			showSettingsScreen(), showSettingsScreenBGColor()
	"\x84\xa9\xae\xa0\xad\xa9\xb8\xa5\xb2\xab\xa0\xc0 \xb0\xaf\xa4\xb2\xa2\xa5\xb3\xab\xa0",	//Динамическая подсветка	showSettingsScreenBacklight()
	"\xa0\xa2\xb3\xaf",	// авто	showSettingsScreen()
	"\x97\xa0\xb2\xbc"	// Часы	showMMenu()
};

namespace settings {
	byte blight = 100;		// яркость подсветки
	bool blightauto = 0;	// динамическая подсветка
	word bgcolor = 0;		// цвет фона
	word tcolor = 0xFFFF;	// цвет текста
	bool analogClock = 0;	// вариант часов
	namespace d {
		bool overlay = 1;	// Runtime: %lu, FPS: %u
	}
}

/* ISR for the Big Button
#define INT_BIG_BUTTON 1	// interrupt for pin 3
#define WAIT_BIG_BUTTON attachInterrupt(INT_BIG_BUTTON, BBHandler, CHANGE)
bool volatile bigbutton = 0;
void BBHandler() { bigbutton = 1; detachInterrupt(INT_BIG_BUTTON); }*/

/******************** конец определений ********************/
//if ((rvv.value>192) && ((gvv.value | bvv.value)<128)) tcl='#00f'; else tcl='#f00';
char* getstr(int id) { return strcpy_P(strbuf, stringtable[id]); }
/*запилил в класс
int dayOfWeek(int d, int m, int y) { return (d+=m<3?y--:y-2,23*m/9+d+4+y/4-y/100+y/400)%7; }
char* dayOfWeekP(int d, int m, int y) { return getstr(dayOfWeek(d,m,y)+1); } //1 = ID 0-дня недели
*/
void setScrLight(byte percent) { analogWrite(TFT_BL, map(percent, 0, 100, 0, 255)); }
/**/
void printCH(int y, byte fontsize, char* str) {
	if (fontsize<1) fontsize=1;
	if (fontsize>25) return;
	//unsigned int symcount=strlen(str);
	unsigned int strpx=strlen(str)/*symcount*/*6*fontsize-1; // because one char w/ size 1 is 5*8 and kerning 1px
	if (strpx<scr.w) tft.setCursor(((scr.w-strpx)/2)+(fontsize/2),y);
	else tft.setCursor(0,y); tft.setTextSize(fontsize);
	 tft.println(str); tft.setTextSize(1);
}
/**/
//PROGMEM variant
void drawPic(int x, int y, int w, int h, const int16_t *pic) {
	for (int cy=0; cy < h; cy++) {
		for (int cx=0; cx < w; cx++) {
			tft.drawPixel(x+cx, y+cy, pgm_read_word(pic + cy*h + cx));
		}
	}
}
/**/
//not-PROGMEM variant
void drawPicRAM(int x, int y, int w, int h, const int16_t *pic) {
	for (int cy=0; cy < h; cy++) {
		for (int cx=0; cx < w; cx++) {
			tft.drawPixel(x+cx, y+cy, pic[cy*h+cx]);
		}
	}
}
/**/
void drawHGLine(int x, int y, int l, word color1, word color2) { // диапазон_цвета/(количечество_пикселей_в_линии-1)
	color c1=color1, c2=color2;
	float dcr=c2.red-c1.red;
	float dcg=c2.green-c1.green;
	float dcb=c2.blue-c1.blue;
	float stepr=dcr/(l-1.0);
	float stepg=dcg/(l-1.0);
	float stepb=dcb/(l-1.0);
	for (int p=0;p<=l;p++) {
		tft.drawPixel(x+p,y, RGB(c1.red+(int)(stepr*p),c1.green+(int)(stepg*p),c1.blue+(int)(stepb*p)));
}}
/**/
void drawVGLine(int x, int y, int l, word color1, word color2) {
	color c1=color1, c2=color2;
	float dcr=c2.red-c1.red;
	float dcg=c2.green-c1.green;
	float dcb=c2.blue-c1.blue;
	float stepr=dcr/(l-1.0);
	float stepg=dcg/(l-1.0);
	float stepb=dcb/(l-1.0);
	for (int p=0;p<=l;p++) {
		tft.drawPixel(x,y+p, RGB(c1.red+(int)(stepr*p),c1.green+(int)(stepg*p),c1.blue+(int)(stepb*p)));
}}
/**/
int numlen(unsigned long number) {
	if (number==0) return 1;
	unsigned long n=number; int nl=0;
	while (n!=0) { n=n/10; nl++; }
	return nl;
}
/**/
/*запилил в класс
void clockset (clocks *c, byte ndd, byte ndm, int ndy, byte nth, byte ntm, byte nts) {
	if (ndd<32) { c->dd=ndd; c->upd=c->upd|CLKU_DAY; }
	if (ndm<13) { c->dm=ndm; c->upd=c->upd|CLKU_MON; }
	if (ndy!=c->dy) { c->dy=ndy; c->upd=c->upd|CLKU_YEAR; }
	if (nth<25) { c->th=nth; c->upd=c->upd|CLKU_HOUR; }
	if (ntm<60) { c->tm=ntm; c->upd=c->upd|CLKU_MIN; }
	if (nts<60) { c->ts=nts; c->upd=c->upd|CLKU_SEC; }
}

void clocktick (clocks *c) {
	byte maxd;
	switch (c->dm) {
		case 1:
		case 3:
		case 5:
		case 7:
		case 8:
		case 10:
		case 12:
			maxd = 31; break;
		case 4:
		case 6:
		case 9:
		case 11:
			maxd = 30; break;
		case 2:
			if ((c->dy % 4)==0) maxd = 29; else maxd = 28; break;
	}
	c->ts++; c->upd=CLKU_SEC;
	if (c->ts > 59) { c->ts=0; c->tm++; c->upd=c->upd|CLKU_MIN; }
	if (c->tm > 59) { c->tm=0; c->th++; c->upd=c->upd|CLKU_HOUR; }
	if (c->th > 23) { c->th=0; c->dd++; c->upd=c->upd|CLKU_DAY; }
	if (c->dd > maxd) { c->dd=1; c->dm++; c->upd=c->upd|CLKU_MON; }
	if (c->dm > 12) { c->dm=1; c->dy++; c->upd=c->upd|CLKU_YEAR; }
}
*/
/**/
word getch() {
	nowkey=0;
	for (int i=0; i<(KEYS_PINS/2); i++) {
		digitalWrite(KEYS_BASE+i, LOW);
		for (int j=0; j<(KEYS_PINS/2); j++) {
			if (!digitalRead(KEYS_BASE+KEYS_PINS/2+j)) { nowkey=nowkey|(1<<(i*4+j)); /*Serial.print("i:"); Serial.print(i); Serial.print(", j: "); Serial.println(j); */}
		}
		digitalWrite(KEYS_BASE+i, HIGH);
	}
	if (nowkey>0) { keystore=keystore|nowkey; return 0; } else { nowkey=keystore; keystore=0; return nowkey; }
}
/**/
void tMenuNavUp() {
	if (curmenupos>0) {
		tft.setCursor(0,(curmenupos-1)*8+12); tft.println(">");
		tft.print(" "); curmenupos--;
	} else {
		tft.setCursor(0,12); tft.print(" ");
		tft.setCursor(0,(nowscrstrs-1)*8+12);
		tft.print(">"); curmenupos=nowscrstrs-1;
	}
}
/**/
void tMenuNavDown() {
	if (curmenupos<(nowscrstrs-1)) {
		tft.setCursor(0, curmenupos*8+12);
		tft.print(" \n>"); curmenupos++;
	} else {
		tft.setCursor(0,(nowscrstrs-1)*8+12); tft.print(" ");
		tft.setCursor(0,12); tft.print(">"); curmenupos=0;
	}
}
/**/
void makeCMG() { // рисует график и значения
	word pc, gc; tft.setTextColor(settings::tcolor,settings::bgcolor);
	if (cpul==SIZEOF_CM_ARCH-1) { for (int i=0;i<=50;i++) {
		if (i==50) pc=-1; else if (i%5==0) pc=RGB(64,64,64); else pc=0;
		tft.drawPixel(GCX0D-1,GYHD+i,pc);
		tft.drawPixel(GCX0D,GYHD+i,pc);
	}} else { for (int i=0;i<=50;i++) {
		if (i==50) pc=-1; else if (i%5==0) pc=RGB(64,64,64); else pc=0;
		tft.drawPixel(GCX0D+1+cpul*2,GYHD+i,pc);
		tft.drawPixel(GCX0D+2+cpul*2,GYHD+i,pc);
	}}
	gc=RGB(0,255,0);// cpu will be green //if (cpuv[cpul]<80) gc=RGB(0,255,0); else gc=RGB(255,0,0);
	if (cpul>0) tft.drawLine(GCX0D+(cpul-1)*2,GYLD-cpuv[cpul-1]/2,GCX0D+cpul*2,GYLD-cpuv[cpul]/2,gc);
	else tft.drawFastHLine(GCX0D-1,GYLD-cpuv[cpul]/2,2,gc);
	sprintf(strbuf, "%d%%  ",cpuv[cpul]);
	tft.setCursor(135,30);//if (cpuv[cpul]==100) tft.setCursor(GCX0D+12,GYLD+5); else if (cpuv[cpul]<10) tft.setCursor(GCX0D+17,GYLD+5); else tft.setCursor(GCX0D+14,GYLD+5);
	tft.print(strbuf); if (cpul==SIZEOF_CM_ARCH-1) cpul=0; else cpul++;
	
	if (meml==SIZEOF_CM_ARCH-1) { for (int i=0;i<=50;i++) {
		if (i==50) pc=-1; else if (i%5==0) pc=RGB(64,64,64); else pc=0;
		tft.drawPixel(GMX0D-1,GYHD+i,pc);
		tft.drawPixel(GMX0D,GYHD+i,pc);
	}} else { for (int i=0;i<=50;i++) {
		if (i==50) pc=-1; else if (i%5==0) pc=RGB(64,64,64); else pc=0;
		tft.drawPixel(GMX0D+1+meml*2,GYHD+i,pc);
		tft.drawPixel(GMX0D+2+meml*2,GYHD+i,pc);
	}}
	gc=RGB(0,0,255);// ram will be blue //if (memv[meml]<90) gc=RGB(0,255,0); else gc=RGB(255,0,0);
	if (meml>0) tft.drawLine(GMX0D+(meml-1)*2,GYLD-memv[meml-1]/2,GMX0D+meml*2,GYLD-memv[meml]/2,gc);
	else tft.drawFastHLine(GMX0D-1,GYLD-memv[meml]/2,2,gc);
	sprintf(strbuf, "%d%%  ",memv[meml]);
	tft.setCursor(135,50);//if (memv[meml]==100) tft.setCursor(GMX0D+12,GYLD+5); else if (memv[meml]<10) tft.setCursor(GMX0D+17,GYLD+5); else tft.setCursor(GMX0D+14,GYLD+5);
	tft.print(strbuf); if (meml==SIZEOF_CM_ARCH-1) meml=0; else meml++;
}
/**/
/*void fillCM(int cpu, int mem) {
	cpubb = (scr.w-6)/100.0*cpu; membb = (scr.w-6)/100.0*mem;	//stores bars vals
	tft.fillRect(cpubb+3,40,scr.w-6-cpubb,11,0);			//reset CPU bar
	tft.fillRect(membb+3,56,scr.w-6-membb,11,0);			//reset RAM bar
	tft.fillRect(3,40,cpubb,11,RGB(0,255,0));			//fill CPU bar
	tft.fillRect(3,56,membb,11,RGB(0,255,0));			//fill RAM bar
	tft.setTextColor(RGB(255,128,0));
	tft.setCursor(30,42); tft.print("\x87\xa0\xa3\xb1\xb4\xa8\xab\xa0 CPU: "); tft.print(cpu); tft.println("%  ");
	tft.setCursor(30,58); tft.print("\x87\xa0\xa3\xb1\xb4\xa8\xab\xa0 RAM: "); tft.print(mem); tft.println("%  ");	
}*/
/**/
void drawGrid() {	// i use it for aligning elements
	for (int i=0; i<scr.h; i+=5) tft.drawFastHLine(0, i, scr.w, RGB(60,60,60));
	for (int i=0; i<scr.w; i+=5) tft.drawFastVLine(i, 0, scr.h, RGB(60,60,60));
}
/**/
void drawOverlay() {
	tft.setTextSize(1);
	if (settings::d::overlay) {
		tft.setCursor(0,scr.h-16); if (amode==AMODE_CLOCK) tft.print("\n");
		sprintf(strbuf, "Runtime: %lu, FPS: %u   ", looptime/1000, fps);	tft.print(strbuf);
	}
	if (amode==AMODE_CLOCK) tft.setCursor(scr.w/2-16, scr.h-24);
	else tft.setCursor(scr.w/2-20, scr.h-8);
	tft.print(weather); tft.print("\xf8\x43 ");	// °C, хз почему \xf8C = M
	//tft.print("Runtime: "); tft.print(looptime/1000);
	//tft.print(" FPS: "); tft.print(fps); tft.print("  ");
	//tft.print(settings::blight); tft.print("  ");
	//tft.print(SENSOR_LIGHT); tft.print("   ");
	/*{
		int xxx = scr.w/2 + 50 * cos((float)watches.ts*deg2rad(6)-deg2rad(90)); //deg2rad(6) was PI/30
		int yyy = scr.h/2 + 50 * sin((float)watches.ts*deg2rad(6)-deg2rad(90));
		tft.drawPixel(xxx, yyy, RGB(255,0,0));
	}*/
}
/**/
void drawOverlayClock() {
	tft.setCursor(0,scr.h-8); tft.print(watches.th); tft.print(":");
	if (watches.tm<10) tft.print("0"); tft.print(watches.tm); tft.print(":");
	if (watches.ts<10) tft.print("0"); tft.print(watches.ts); tft.print(" ");
	tft.setCursor(scr.w-60,scr.h-8);
	if (watches.upd>CLKU_HOUR) {
		if (watches.dd<10) tft.print("0"); tft.print(watches.dd); tft.print("/");
		if (watches.dm<10) tft.print("0"); tft.print(watches.dm); tft.print("/");
		tft.print(watches.dy);
	}
}
/**/
void showSummary() {
	//tft.setTextSize(2); tft.fillRect(0,0,scr.w,36,RGB(240,240,240));
	//tft.setCursor(24,3); tft.drawRect(1,1,scr.w-2,34,RGB(192,192,192));
	//tft.print("\x91\xa9\xb2\xb3\xa5\xad\xae\xbc\xaa\n   \xad\xaf\xae\xa9\xb3\xaf\xb1");
	//tft.setTextColor(-1); tft.setTextSize(1);
	printCH(0,1,getstr(0));	
	//tft.drawRoundRect(1,38,scr.w-2,15,2,RGB(0,255,0));	//draw place for CPUmeter
	//tft.drawRoundRect(1,54,scr.w-2,15,2,RGB(0,255,0));	//draw place for RAMmeter

	tft.setCursor(135,20/*GCX0D+19,GYHD-10*/);
	tft.setTextColor(RGB(0,255,0)); tft.print("CPU"); cpul=0;
	tft.drawFastVLine(GCX0D-2,GYHD,50,settings::tcolor);
	tft.drawFastHLine(GCX0D-1,GYLD,SIZEOF_CM_ARCH*2,settings::tcolor);
	tft.setCursor(135,40/*GMX0D+19,GYHD-10*/);
	tft.setTextColor(RGB(0,0,255)); tft.print("RAM"); meml=0;
	//tft.drawFastVLine(GMX0D-2,GYHD,50,-1); tft.drawFastHLine(GMX0D-1,GYLD,SIZEOF_CM_ARCH*2,-1);
	//obsolete, for separate graphs
}
/**/
void showMMenu() { printCH(0, 1, getstr(8));
	tft.drawBitmap(29,15,icon_Clock,24,24,settings::tcolor);
	tft.drawBitmap(110,15,icon_Settings,24,24,settings::tcolor);

	tft.setCursor(19,44);	tft.print(getstr(16));
	tft.setCursor(27,52);	tft.print("C4");
	tft.setCursor(103,44);	tft.print(getstr(9));
	tft.setCursor(125,52);	tft.print("D1");
	
	drawPic(scr.w-50,scr.h-64,50,50,AlexB);
}
/**/
void showSettings() { printCH(0, 1, getstr(9));
	tft.drawFastHLine(0,10,scr.w,settings::tcolor);
	
	tft.setCursor(0,12); nowscrstrs=3; curmenupos=0;
	tft.print("> "); tft.println(getstr(10)); //screen settings
	tft.println("  Debug - overlay switch");
	tft.println("  Another string");

	tft.setCursor(scr.w-30,scr.h-30); tft.print("keys");
}
/**/
void showSettingsScreen() {
	pamode=AMODE_SETTINGS; printCH(0, 1, getstr(10)); //screen settings
	tft.drawFastHLine(0,10,scr.w,settings::tcolor);
	
	tft.setCursor(0,12); nowscrstrs=3; curmenupos=0;
	tft.print("> "); tft.print(getstr(11)); tft.print(": ");	//backlight level
	if (settings::blightauto) tft.println(getstr(15));		//auto
	else tft.println(settings::blight);
	tft.print("  "); tft.print(getstr(12)); tft.print(": ");	//text color
	tft.drawRect(tft.getCursorX(),tft.getCursorY(),16,8,RGB(128,128,128));
	tft.fillRect(tft.getCursorX()+1,tft.getCursorY()+1,14,6,settings::tcolor);
	tft.print("\n  "); tft.print(getstr(13)); tft.print(": ");	//back color
	tft.drawRect(tft.getCursorX(),tft.getCursorY(),16,8,RGB(128,128,128));
	tft.fillRect(tft.getCursorX()+1,tft.getCursorY()+1,14,6,settings::bgcolor);

	tft.setCursor(scr.w-30,scr.h-30); tft.print("keys");
}
/**/
void showSettingsScreenBacklight() {
	pamode=AMODE_SETTINGS_SCREEN; printCH(0, 1, getstr(11)); //backlight level
	tft.drawFastHLine(0,10,scr.w,settings::tcolor);
	tft.setCursor(0,12); tft.print(getstr(14)); tft.print(" ");	//dynamic backlight
	tft.drawRect(tft.getCursorX()-1,tft.getCursorY()+1, 7, 7, settings::tcolor);
	if (settings::blightauto) tft.print((char)201); else tft.print((char)200);	//tick or off-tick

	for (int i=0; i<3; i++) tft.drawFastHLine(10, scr.h/2+i, scr.w-20, settings::tcolor);
	tft.drawFastVLine(10, scr.h/2-2, 7, settings::tcolor);
	tft.drawFastVLine(scr.w-10, scr.h/2-2, 7, settings::tcolor);
	sprintf(strbuf, "%d%%", settings::blight); printCH(scr.h/2-20, 2, strbuf);
	tft.setCursor(scr.w-(scr.w-10)+settings::blight/100.0*(scr.w-20)-2,scr.h/2+8); // firstX of line + lenght of line * percent - half of symbol
	tft.print("^"); dbuf=settings::blight; bbuf=settings::blightauto;	
}
/**/
void helperChangeBacklightSetting(int c) {
	int placingX; if (c!=0) { settings::blight+=c; setScrLight(settings::blight); } // dynamic blight setting process optimisation
	sprintf(strbuf, " %d%% ", settings::blight); printCH(scr.h/2-20, 2, strbuf);
	placingX=10+settings::blight/100.0*(scr.w-20)-2; // firstX of line + lenght of line * percent - half of symbol
	tft.setCursor(placingX,scr.h/2+8); tft.fillRect(0,scr.h/2+8,scr.w,8,settings::bgcolor); tft.print("^");
	//if (c<0) tft.print("     "); else tft.fillRect(placingX-30,scr.h/2+8,30,8,settings::bgcolor); // erase previous ^
}
/**/
void helperRGBSelect(int c, int cc, color newcol) { //c is change, cc is changing color (1r/2g/3b/-1spec)
	if (cc==-1) {
		switch (amode) {
			case AMODE_SETTINGS_SCREEN_TCOLOR: settings::tcolor=colbuf.get16(); break;
			case AMODE_SETTINGS_SCREEN_BGCOLOR: settings::bgcolor=colbuf.get16(); break;
		}
		return;
	}
	if (c==0) {
		for (int i=0; i<3; i++) { // thickness=3
			drawHGLine(5, 20+i, scr.w-30, 0, RGB(255,0,0));
			drawHGLine(5, 40+i, scr.w-30, 0, RGB(0,255,0));
			drawHGLine(5, 60+i, scr.w-30, 0, RGB(0,0,255));
		}
		for (int i=0; i<3; i++) { // colors=3
			word cc[3]={RGB(255,0,0),RGB(0,255,0),RGB(0,0,255)};
			tft.drawFastVLine(5, 18+i*20, 7, 0); //-1 is temp, must be 0
			tft.drawFastVLine(scr.w-25, 18+i*20, 7, cc[i]);
	}}
	else {
		int plcold;
		switch (cc) {
			case 1: plcold=5+newcol.red/248.0*(scr.w-30)-2; newcol.red+=c; break;
			case 2: plcold=5+newcol.green/252.0*(scr.w-30)-2; newcol.green+=c; break;
			case 3: plcold=5+newcol.blue/248.0*(scr.w-30)-2; newcol.blue+=c; break;
		}
		tft.setCursor(plcold,20*cc+5); tft.print(" ");
	}
	if (c==0 || cc==1) {
		int plcR=5+newcol.red/248.0*(scr.w-30)-2;
		tft.setCursor(plcR,25); tft.print("^");
		tft.setCursor(scr.w-20, 18); tft.print(newcol.red);
		for(int i=numlen(newcol.red);i<3;i++) tft.print(" ");
	}
	if (c==0 || cc==2) {
		int plcG=5+newcol.green/252.0*(scr.w-30)-2;	
		tft.setCursor(plcG,45); tft.print("^");
		tft.setCursor(scr.w-20, 38); tft.print(newcol.green);
		for(int i=numlen(newcol.green);i<3;i++) tft.print(" ");
	}
	if (c==0 || cc==3) {
		int plcB=5+newcol.blue/248.0*(scr.w-30)-2;
		tft.setCursor(plcB,65); tft.print("^");
		tft.setCursor(scr.w-20, 58); tft.print(newcol.blue);
		for(int i=numlen(newcol.blue);i<3;i++) tft.print(" ");
	}

	switch (amode) {
		case AMODE_SETTINGS_SCREEN_TCOLOR: tft.setTextColor(newcol.get16(),settings::bgcolor); break;
		case AMODE_SETTINGS_SCREEN_BGCOLOR: tft.setTextColor(settings::tcolor,newcol.get16()); break;
	}	
	printCH(80, 1, "Text example"); tft.setTextColor(settings::tcolor,settings::bgcolor); colbuf=newcol;
}
/**/
void showSettingsScreenTColor() {
	pamode=AMODE_SETTINGS_SCREEN; printCH(0, 1, getstr(12)); //text color
	tft.drawFastHLine(0,10,scr.w,settings::tcolor);
	helperRGBSelect(0,0,settings::tcolor);
}
/**/
void showSettingsScreenBGColor() {
	pamode=AMODE_SETTINGS_SCREEN; printCH(0, 1, getstr(13)); //background color
	tft.drawFastHLine(0,10,scr.w,settings::tcolor);
	helperRGBSelect(0,0,settings::bgcolor);
}
/**/
void showClockWatch() {/*there's nothing to do yet*/}
/**/
uint16_t read16(File f) {
  uint16_t result;
  ((uint8_t *)&result)[0] = f.read(); // LSB
  ((uint8_t *)&result)[1] = f.read(); // MSB
  return result;
}

uint32_t read32(File f) {
  uint32_t result;
  ((uint8_t *)&result)[0] = f.read(); // LSB
  ((uint8_t *)&result)[1] = f.read();
  ((uint8_t *)&result)[2] = f.read();
  ((uint8_t *)&result)[3] = f.read(); // MSB
  return result;
}
/**/
void showTest() { 
	char* titletxt = "Test mode";	printCH(0,1,titletxt);
	tft.setCursor(0,10); tft.print("A0:\nA1:\nA1toU:\nU2R:\nR2T:");
#define BXBASE 0
#define BYBASE 127
	File bmp; uint32_t bmpst, bmpw; int32_t bmph; uint16_t bmpd; uint32_t bmps;
	coords cp; cp.x=BXBASE; cp.y=BYBASE; color cc; byte tribuf[3];
	if (!sdmount) sdmount=SD.begin(SD_CS);
	if (sdmount) { if (bmp = SD.open("scrtest.bmp")) { 
		if (read16(bmp) == 0x4d42) {
			bmp.seek(0xa); bmpst=read32(bmp);
			bmp.seek(0x12); bmpw=read32(bmp); bmph=read32(bmp);
			bmp.seek(0x1c); bmpd=read16(bmp);
			bmp.seek(0x22); bmps=read32(bmp);

			bmp.seek(bmpst);
			
			tft.setAddrWindow(cp.x, cp.y, cp.x+bmpw-1, cp.y+1);
			
			while(bmp.position() < bmpst+bmps) {
				bmp.read(tribuf,3); cc.blue=tribuf[0];
				cc.green=tribuf[1]; cc.red=tribuf[2];

				//tft.drawPixel(cp.x, cp.y, cc.get16());
				//tft.setAddrWindow(cp.x,cp.y,cp.x+1,cp.y+1);
				tft.pushColor(cc.get16());
				
				if (cp.x<BXBASE+bmpw-1) cp.x++;
				else {
					cp.x=BXBASE; cp.y--;
					if (bmpw%4>0) bmp.read(tribuf,bmpw%4);
					tft.setAddrWindow(cp.x, cp.y, cp.x+bmpw-1, cp.y+1);
				}
			}
		}
		else tft.print("\nBMP sig fail"); bmp.close();
	} else tft.print("\nFile open fails"); }
	else tft.print("\nSD open fails");
	tft.setCursor(0,58); tft.print("UNIXTIME: ");
}
/**/
void BSOD() { // i did it for lulz but it really stops anything
	tft.setTextWrap(1); tft.fillScreen(RGB(0,0,128));
	tft.setTextColor(-1,-1); tft.setCursor(0,0);
	tft.print("\nA problem has been detected and Arduino Assistant has been shut down to prevent damage to your board.\n\
The problem seems to be caused by the following function: (void)loop\n\n\
MANUALLY_INITIATED_CRASH\n\n\
Technical information:\n\n0xDEADDEAD (0x0,0x0,0x0,0xE2)");
	for (;;) delay(0);
}
/**/
void setMode(byte mode) { pamode=AMODE_SUMMARY; //its temporary
	amode=mode; tft.setCursor(0,0); tft.setTextSize(1); watches.upd=0b111111; // 0b111111 means full update
	tft.fillScreen(settings::bgcolor); tft.setTextColor(settings::tcolor); curmenupos=nowscrstrs=0;
	switch (mode) {
		case AMODE_MAINMENU: showMMenu(); break;
		case AMODE_SUMMARY: showSummary(); break;
		case AMODE_CLOCK: showClockWatch(); break;
		case AMODE_SETTINGS: showSettings(); break;
		case AMODE_SETTINGS_SCREEN: showSettingsScreen(); break;
		case AMODE_SETTINGS_SCREEN_BACKLIGHT: showSettingsScreenBacklight(); break;
		case AMODE_SETTINGS_SCREEN_TCOLOR: showSettingsScreenTColor(); break;
		case AMODE_SETTINGS_SCREEN_BGCOLOR: showSettingsScreenBGColor(); break;
		case AMODE_TEST: showTest(); break;
	}
	//drawGrid();
}
/**/
void initScreen() {
	tft.initR(INITR_BLACKTAB); tft.cp437(1);			// инициализируем экран и заставляем не пропускать символ 176(10)/B0(16)
	tft.setRotation(1/*3*/); tft.fillScreen(settings::bgcolor);	// поворачиваем экран на 270 и заливаем цветом фона
	scr.w = tft.width(); scr.h = tft.height();			// копируем текущую высоту и ширину экрана (минимизация обращений к функциям)
	tft.setTextWrap(false);// tft.setTextColor(0);	

#ifdef _WE_HAVE_OLED_128_64
	oled.begin(SSD1306_SWITCHCAPVCC, 0x3C); //i2c addr==3c
	oled.clearDisplay(); oled.setCursor(0,0);
	oled.setTextColor(1); oled.setTextSize(1);
	oled.setTextWrap(false); oled.display();
#endif
}
/**/
void setup() {
	pinMode(BL, OUTPUT); digitalWrite(BL, LOW);
	memset(cpuv,0,SIZEOF_CM_ARCH); memset(memv,0,SIZEOF_CM_ARCH);		// зануляем графики цыпы и памяти
	Serial.begin(115200); initScreen(); setScrLight(settings::blight);	// запускаем Serial с экраном и ставим уровень подсветки из настроек
	#ifndef _WE_USE_ONEWIRE
	outtemp = TR2T(SENSOR_TEMP,10000,3950);	// стартовое значение термодатчика
	#else
	if (ow.reset()) {
		ow.select(ow_addr_out_temp);
		ow.write(0x44);	//start conversion
	}
	#endif
	//tft.drawFastHLine(0,100,scr.w,1200);	//test zone delim
	for (int i=0; i<(KEYS_PINS/2); i++) { pinMode(KEYS_BASE+i, OUTPUT); pinMode(KEYS_BASE+KEYS_PINS/2+i, INPUT_PULLUP); }
	

#ifdef RTC_NOT_READY
for (int i=14; i<19; i++) {pinMode(i,OUTPUT); digitalWrite(i,0);}
#else
	pinMode(17,OUTPUT); digitalWrite(17,0);
	pinMode(18,OUTPUT); digitalWrite(18,1);
	watches.set(RTC.get());
#endif
	/* some vector graphics and idiot texts
	tft.drawCircle((scr.w / 2 - 20), 50, 10, -1);	tft.drawCircle((scr.w / 2 + 20), 50, 10, -1);
	tft.drawLine(scr.w / 2,60,scr.w / 2 + 10,80,-1); tft.drawLine(scr.w / 2 - 5,85,scr.w / 2 + 10,80,-1);
	tft.drawLine(40,100,80,100,-1); tft.drawLine(20,80,40,100,-1); tft.drawLine(100,80,80,100,-1);
	tft.setCursor(scr.w-30, 90); tft.print("LOL");
	tft.setCursor(0,140); tft.println("\x9e\x8b\x9f \x8f\x85\x8a\x80\x90\x9c! \x02"); //AlexB Trololo
	*/
	/* drawing alphabet (А-Я без Ё и а-я) ACHTUNG CP437!!!
	tft.setCursor(0,25);
	tft.println("\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a");	//А-К
	tft.println("\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95");	//Л-Х
	tft.println("\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\n");		//Ц-Я

	tft.println("\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa");	//а-й
	tft.println("\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5");	//к-ф
	tft.println("\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0");	//х-я
	*/
	showSummary();
	//test1.x=20; test1.y=20;
}

void loop() {
	looptime = millis();
	if (looptime < lasttime) { lasttime = 0; }
	if (looptime > lasttime + 10000) {
		//cpu = 0; mem = 0;	//obsolete??
		if (synced) {
			toparse="";
			/*if (amode==AMODE_SUMMARY) {
				tft.fillRect(3,40,scr.w-6,11,RGB(0,0,0));	//fill CPU bar
				tft.fillRect(3,56,scr.w-6,11,RGB(0,0,0));	//fill RAM bar
			}*/
			synced = 0;
		}		
		if (looptime%1000 > 500) //BLs = 1; else BLs = 0; digitalWrite(BL, BLs);
		PORTB = PORTB | 0b10000000;		//enable HIGH on port B7 (13)
		else PORTB = PORTB & 0b01111111;	//disable HIGH on port B7
		if (weather!=int(outtemp)) weather=int(outtemp); // меняем показания с компа на свои
	}
	if (Serial.available()>0) {
		synced = 1; PORTB = PORTB & 0b01111111;//BLs = 0; digitalWrite(BL, BLs);
    		while (Serial.available()) {
			geter = Serial.read();
			if (geter=='\xff') { istrok=1; break; } else toparse += geter;
	}}
	if (istrok) { //refresh all only if string OK
		/* some info about using packets
		 * format: NPL0000000C0XXD where		 
		 * NP		"New packet"
		 * L0000000	like sizeof => data limited to 9999985 bytes (9,53 MB)
		 * C0		number of packet (for callback)
		 * XX		mode and type of request (see definitions section)
		 * D			if needed, means "data"; IRL anything
		*/
		lasttime = looptime; ret=""; istrok=0;			// обновляем время последней обработки пакета и сбрасываем строку ответа и флаг конца пакета
		plen = (toparse.substring(3, 10)).toInt();		// gets packet length from symbol 3 to 9
		pnum = (toparse.substring(11, plen)).toInt();	// gets packet number from symbol 11 to ??? xD
		if (toparse.length()==plen) {					// continue only if length check OK
			int npp = numlen(pnum);					// count next parsing position in packet number
			pmode = toparse.charAt(11+npp);			// gets packet mode
			ptype = toparse.charAt(11+npp+1);			// gets packet type
			npp+=13;
			switch (pmode) {	// operation switch
				case IM_EMULATE:
					switch (ptype) {
						case IP_EMU_KEY:
							keysval=toparse.substring(npp, npp+5).toInt();
							ret="REK"; ret+=keysval;
							break;
						default: ret="EET";
					}
					break;
				case IM_HELLO:
					ret = "HELLO";
					break;
				case IM_GET:
					switch (ptype) {
						case IP_GET_FREERAM: ret="R"; ret+=freeRam(); break;
						case IP_GET_RUNTIME: ret="R"; ret+=(looptime/1000); break;
						case IP_GET_WEATHER: ret="R"; ret+=outtemp; break;
						default: ret="EGT";
					}
					break;
				case IM_SET:
					switch (ptype) {
						case IP_SET_CLOCK:
							watches.set((toparse.substring(npp, npp+2)).toInt(), (toparse.substring(npp+2, npp+4)).toInt(), (toparse.substring(npp+4, npp+6)).toInt()+2000, (toparse.substring(npp+6, npp+8)).toInt(), (toparse.substring(npp+8, npp+10)).toInt(), (toparse.substring(npp+10, npp+12)).toInt());
					#ifndef RTC_NOT_READY
							RTC.set(watches.UNIX());
					#endif
							ret = "R"; ret += watches.th; ret += watches.tm; ret += watches.ts;
							break;
						case IP_SET_CPUMEM:							
							cpuv[cpul] = /*cpu = */(toparse.substring(npp, npp+3)).toInt();		//gets CPU val
							memv[meml] = /*mem = */(toparse.substring(npp+3, npp+6)).toInt();	//gets MEM val
							ret = "RC"; ret += cpuv[cpul]/*cpu*/; ret += "M"; ret += memv[meml]/*mem*/;
							if (amode==AMODE_SUMMARY) makeCMG();//fillCM(cpu,mem);
							break;
						case IP_SET_MODE:
							setMode(toparse.substring(npp, npp+3).toInt());
							ret = "RA"; ret += amode; ret += "P"; ret += pamode;
							break;
						case IP_SET_WEATHER:
							dbuf = (toparse.substring(npp, npp+3)).toInt();
							if (dbuf > 100) weather = (dbuf - 100) * (-1); else weather = dbuf;
							if (weather < 0) { ret = "RWM"; ret += (weather * (-1)); } else { ret = "RWP"; ret += weather; }
							break;
						default: ret="EST";
					}
					break;
				default: ret="EM";
			}
		} else { ret = "EL"; }
		ret = "D" + ret; ret = pnum + ret; ret = "C" + ret;
		plen = ret.length() + 8;
		String addlen=""; addlen+=plen;
		while (addlen.length()<7) addlen="0"+addlen;
		ret = addlen + ret; ret = "L" + ret;
		Serial.println(ret); istrok=0; toparse="";
	}
	if (pmode==IM_EMULATE && ptype==IP_EMU_KEY) pmode=ptype=0; else keysval=getch();
	if (keysval>0) {// tft.setCursor(0,scr.h-40); tft.print("K: "); tft.print(keysval); tft.print("    "); keysval=0; } else { tft.setCursor(0,scr.h-40);tft.print("K: 0    "); }
		switch (amode) { //каждому режиму свои кнопки
			case AMODE_SETTINGS: switch (keysval) {
				case KA4: setMode(AMODE_TEST); break;
				case KC2: tMenuNavUp(); break;
				case KC4: tMenuNavDown(); break;
				case KC3:
					if (curmenupos==0) setMode(AMODE_SETTINGS_SCREEN);
					if (curmenupos==1) settings::d::overlay=!settings::d::overlay;
					break;
				default: setMode(AMODE_SUMMARY);
			} break;
			case AMODE_SETTINGS_SCREEN: switch (keysval) {
				case KC2: tMenuNavUp(); break;
				case KC4: tMenuNavDown(); break;
				case KC3: switch (curmenupos) {
						case 0: setMode(AMODE_SETTINGS_SCREEN_BACKLIGHT); break;
						case 1: setMode(AMODE_SETTINGS_SCREEN_TCOLOR); break;
						case 2: setMode(AMODE_SETTINGS_SCREEN_BGCOLOR); break;
					} break;
				default: setMode(pamode);
			} break;
			case AMODE_SETTINGS_SCREEN_BACKLIGHT: switch (keysval) {
				case KB3: if (settings::blight>4) helperChangeBacklightSetting(-5); break;
				case KA3: if (settings::blight>19) helperChangeBacklightSetting(-20); break;
				case KC3: if (settings::blight<96) helperChangeBacklightSetting(5); break;
				case KD3: if (settings::blight<81) helperChangeBacklightSetting(20); break;
				case KC2:
					settings::blightauto=!settings::blightauto;
					tft.setCursor(138,12);
					if (settings::blightauto) tft.print((char)201);
					else tft.print((char)200);
					tft.drawRect(tft.getCursorX()-7,tft.getCursorY()+1, 7, 7, settings::tcolor);
					break;
				case KD1: setMode(pamode); break;
				default: settings::blight=dbuf; settings::blightauto=bbuf; setScrLight(settings::blight); setMode(pamode);
			} break;
			case AMODE_SETTINGS_SCREEN_TCOLOR:
			case AMODE_SETTINGS_SCREEN_BGCOLOR: switch(keysval) {
				case KA2: helperRGBSelect(-32, 1, colbuf); break;
				case KB2: helperRGBSelect(-8, 1, colbuf); break;
				case KC2: helperRGBSelect(8, 1, colbuf); break;
				case KD2: helperRGBSelect(32, 1, colbuf); break;
				case KA3: helperRGBSelect(-32, 2, colbuf); break;
				case KB3: helperRGBSelect(-4, 2, colbuf); break;
				case KC3: helperRGBSelect(4, 2, colbuf); break;
				case KD3: helperRGBSelect(32, 2, colbuf); break;
				case KA4: helperRGBSelect(-32, 3, colbuf); break;
				case KB4: helperRGBSelect(-8, 3, colbuf); break;
				case KC4: helperRGBSelect(8, 3, colbuf); break;
				case KD4: helperRGBSelect(32, 3, colbuf); break;
				case KD1: helperRGBSelect(0,-1,0); // save and exit
				default: setMode(pamode); break;
			} break;
			default: switch (keysval) {
				case KC4: setMode(AMODE_CLOCK); break;
				case KD1: setMode(AMODE_SETTINGS); break;
				case KD4: setMode(AMODE_MAINMENU); break;
				case (KB1+KB3): initScreen();
				default: setMode(AMODE_SUMMARY);
			}
		}
	}
	if (looptime%1000 < pulser) {	//once-per-second routine
		tft.setTextColor(settings::tcolor,settings::bgcolor); // чтобы не проёбывать цвет
#ifndef _WE_USE_ONEWIRE
		{	// обновляем температуру
			float check = TR2T(SENSOR_TEMP,10000,3950);
			if (check>outtemp) outtemp+=0.01;
			if (check<outtemp) outtemp-=0.01; 
		}
#else
		if (ow.reset()) {
			byte owdata[12];
			ow.select(ow_addr_out_temp);
			ow.write(0xbe);	//read scratchpad
			for (int i=0;i<9;i++) owdata[i]=ow.read();
			if (ow.crc8(owdata,8)==owdata[8]) {
				int16_t raw=(owdata[1]<<8)|owdata[0];
				switch (owdata[4]&0x60) {
					case 0x00: raw=raw&~7;
					case 0x20: raw=raw&~3;
					case 0x40: raw=raw&~1;
				}
				outtemp=(float)raw/16.0;
			}
			ow.reset();
			ow.select(ow_addr_out_temp);
			ow.write(0x44);	//start conversion
		} else PORTB = PORTB | 0b10000000;		//enable HIGH on port B7 (13) //else indicate error! //this is temporary shit
#endif
		if (settings::blightauto) {
			if (SENSOR_LIGHT>=600 && settings::blight!=100) settings::blight=100;
			if (SENSOR_LIGHT>=450 && SENSOR_LIGHT<600 && settings::blight!=75) settings::blight=75;
			if (SENSOR_LIGHT>=300 && SENSOR_LIGHT<450 && settings::blight!=50) settings::blight=50;
			if (SENSOR_LIGHT>=150 && SENSOR_LIGHT<300 && settings::blight!=25) settings::blight=25;
			if (SENSOR_LIGHT>=80 && SENSOR_LIGHT<100 && settings::blight!=20) settings::blight=20;
			if (SENSOR_LIGHT>=50 && SENSOR_LIGHT<80 && settings::blight!=10) settings::blight=10;
			if (SENSOR_LIGHT<50 && settings::blight!=5) settings::blight=5;
			if (amode==AMODE_SETTINGS_SCREEN_BACKLIGHT) helperChangeBacklightSetting(0);
			setScrLight(settings::blight);
		}
		switch (amode) {
			case AMODE_CLOCK:
				if (settings::analogClock) { printCH(scr.h/2, 1, "xyu me"); }
				else {
					if (scr.w<141) tft.setTextSize(2); else tft.setTextSize(3); // length of 8 symbols size 3 is 141 (7-123)
					if (watches.upd & CLKU_HOUR) {
						if (watches.th<10) { tft.setCursor(0,scr.h/2-24); tft.print(" "); }
						else tft.setCursor(7, scr.h/2-24); tft.print(watches.th); tft.print(": ");
					}
					if (watches.upd & CLKU_MIN) {
						if (watches.th<10) tft.setCursor(54,scr.h/2-24);
						else tft.setCursor(63, scr.h/2-24);
						if (watches.tm<10) tft.print("0");
						tft.print(watches.tm); tft.print(": ");
					}					
					if (watches.upd & CLKU_SEC) {
						if (watches.th<10) tft.setCursor(109,scr.h/2-24);
						else tft.setCursor(119, scr.h/2-24);
						if (watches.ts<10) tft.print("0");
						if (watches.upd & CLKU_HOUR) tft.fillRect(145,scr.h/2-24,15,24,settings::bgcolor);
						tft.print(watches.ts);
					}
					tft.setTextSize(2);
					if (watches.upd & CLKU_DAY) { tft.setCursor(20,scr.h/2); if (watches.dd<10) tft.print("0"); tft.print(watches.dd); tft.print("/"); } // length of 10 symbols size 2 is 120 (9-108)
					if (watches.upd & CLKU_MON) { if (watches.dm<10) tft.print("0"); tft.print(watches.dm); tft.print("/"); }
					if (watches.upd & CLKU_YEAR) tft.print(watches.dy);
					if (watches.upd & CLKU_DAY) { tft.fillRect(40,scr.h/2+16,80,8,settings::bgcolor); printCH(scr.h/2+16, 1, watches.dayOfWeekP());}
				}
				break;
			case AMODE_TEST:
				tft.setCursor(24,10); tft.print(SENSOR_LIGHT); tft.print("   ");
				{
					int ts = SENSOR_TEMP;
					tft.setCursor(24,18); tft.print(ts); tft.print("   ");
					tft.setCursor(42,26); tft.print(ADC2U(ts)); tft.print(" V    ");
					tft.setCursor(30,34); tft.print(RD2R(5,ADC2U(ts),10000)); tft.print(/*" / "); tft.print(50000/(ts / 1023.0 * 5.0)-10000); tft.print(*/"    ");
					/*double pt1=log((10000.0/(5.0/(ts / 1023.0 * 5.0) - 1.0))/10000.0);
					//double pt2=log((50000.0/(ts / 1023.0 * 5.0)-10000.0)/10000.0);
					double t1=1.0/(1.0/298.15 + 1.0/3950.0*pt1)-273.15;
					//float t2=1.0/(1.0/298.15 + 1.0/3950.0*pt2)-273.15;*/
					//float ow=1.0/(1.0/298.15 + 1.0/3950.0*log(RD2R(5,ADC2U(ts),10000)/10000.0))-273.15;
					tft.setCursor(30,42); tft.print(TR2T(ts,10000,3950)); tft.print("   ");
					tft.setCursor(60,58); tft.print(long(watches.UNIX()));
				}
				//!nobreak!
			default: drawOverlayClock();
		}
#ifdef _WE_HAVE_OLED_128_64
		//memset(strbuf, 0, 256);
		oled.clearDisplay();
		sprintf(strbuf, "%2d:%02d:%02d", watches.th, watches.tm, watches.ts);
		oled.setTextSize(2); oled.setCursor(18,0); oled.print(strbuf);
		sprintf(strbuf, "%2d.%02d.%04d", watches.dd, watches.dm, watches.dy);
		oled.setTextSize(1); oled.setCursor(36,18); oled.print(strbuf);
		
		//\n%s\n\n%d	, watches.dayOfWeekP(), weather	CENTERING???
		//на oled рисуем ds18b20 если он приляпан
#ifdef _WE_USE_ONEWIRE
		dbuf=outtemp;
		sprintf(strbuf, "%+d\xf8\x43", dbuf);
#else
		sprintf(strbuf, "%+d\xf8\x43", weather);
#endif
		oled.setCursor(52,30); oled.print(strbuf);

		if (synced) {
			byte readpos; if (cpul==0) readpos=SIZEOF_CM_ARCH; else readpos=cpul-1; //костыль x2, cpul/meml++ в makeCMG, cpul==meml
			sprintf(strbuf, "CPU: %d%%, RAM: %d%%", cpuv[readpos], memv[readpos]);
			oled.setCursor(0,56); oled.print(strbuf);	
		}
		
		oled.display();
#endif
		drawOverlay();
#ifndef RTC_NOT_READY
		if (watches.upd & CLKU_MIN) watches.set(RTC.get());
#endif
		fps=0; watches.tick();
	}
	//pixel redraw speed test
	/*if (amode==AMODE_TEST) {
		tft.drawPixel(test1.x,test1.y, RGB(50,50,50));
		test1.x++; if (test1.x>100) test1.x=20;
		tft.drawPixel(test1.x,test1.y, RGB(0,255,0));
	}*/
	fps++; pulser = looptime%1000;
}
